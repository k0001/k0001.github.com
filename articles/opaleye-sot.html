<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="../style/tufte.css" type="text/css" />
</head>
<body>
<p><nav><a href="../">Home</a> § <a href="../">About</a></nav></p>
<h1 id="opaleyes-sugar-on-top">Opaleye’s sugar on top</h1>
<p class="subtitle">
SQL in the type system where it belongs
</p>
<p>People often talk of how solutions fall naturally into place when we program in Haskell and embrace its type system. This article walks us through that process, serving as a gentle introduction to some practical uses of advanced features of the Haskell type system within the context of Opaleye and SQL. I invite you to continue reading even if you are not particularly interested in Opaleye nor SQL, as the approach explained here can be used in other contexts too.</p>
<p><strong>This is not introductory material to Haskell</strong>. For things here to truly make sense, you are expected to be comfortable with concepts like <code>Functor</code>, <code>Monad</code> , <code>Arrow</code> and <code>Lens</code> at least. This is a very long article that intends to teach you how to use the GHC type system to build resilient software and reason about any problem you might want to tackle with it. Nevertheless, even if you don’t particularly understand the technical details, you should be able to follow the reasoning process and appreciate the practical results.</p>
<h2 id="the-problem">The problem</h2>
<p>Reading, writing and maintaining hand-written SQL is hard and error prone. Over the years and in many languages, people have tried to mitigate this problem to different extents by creating tools that convert data types back and forth between SQL and more practical runtime representations, and by creating vocabularies for expressing queries or manipulation routines over the contents of a database in ways that are clearer and more maintainable than just plain hand-written SQL.</p>
<p>The <a href="https://www.haskell.org/">Haskell</a> language ecosystem has had a number of solutions to this problem too. Of these, powerful libraries such as Tom Ellis’ <a href="https://hackage.haskell.org/package/opaleye"><code>opaleye</code></a> and Kei Hibino’s <a href="https://hackage.haskell.org/package/relational-record"><code>relational-record</code></a> are of particular interest to us today. What is special about these libraries is that, making different trade-offs, they guarantee that they will always generate well-formed SQL. The way they achieve this, as is usually the case in Haskell, is by choosing to build their vocabulary on top of precise abstractions ensuring that only things that make sense can be <em>composed</em> together. In practical terms, this means that if we try to, for example, insert an SQL table into a left join, then our program will fail to compile because there is no sensible way in which we can compose an SQL table and a left join by means of inserting the former into the latter. This predictability in what can and cannot be composed gives us new ways to reason formally about the queries that we write, which takes us a long way from that old problem of being unable to read, write or maintain hand-written SQL effectively and efficiently.</p>
<p>However, none of this means we won’t ever generate <em>the wrong SQL</em> when using these tools, as there is still room for making mistakes such as mistyping the name of a column or a table, which will lead to a well-formed but undesired SQL being generated. It is important that we understand this difference between what is well-formed SQL and what is the right SQL (as opposed to <em>the wrong SQL</em>). Is <code>SELECT user.name FROM user</code> well-formed? Yes it is. But is it right or wrong? Unfortunately we can’t tell without more context, as the answer depends on whether <code>user.name</code> was really the value we wanted to select, and on whether the <code>user</code> table exists in the database and is the actual table we were interested in. Otherwise, it might have been a mistake on our part when typing the column name, or maybe we wanted to select <code>song.name</code> but accidentally referred to the wrong table. In general, libraries such as <code>opaleye</code> and <code>relational-record</code> can guarantee that they will generate well-formed SQL for us, but they cannot—justifiably so—judge a well-formed SQL and decide whether it is right or wrong, because these tools can’t possibly know and understand the meaning and purpose of said SQL. Nevertheless, we can improve the situation a bit by making it harder for users of these libraries to write what they consider to be <em>the wrong SQL</em>.</p>
<p>Today we will focus on Opaleye, and in particular I want to talk about <a href="https://github.com/k0001/opaleye-sot">opaleye-sot</a>, a yet unreleased library I have been working on for a while that brings some ideas worth sharing, as they showcase some advanced uses of the type system that have concrete practical benefits and can be useful for solving other problems too. As the name—short for “Opaleye’s sugar on top”—hopefully indicates, this is just a thin layer of new features on top of Opaleye’s standard offer, and it is intended to complement Opaleye, not to replace it. <code>opaleye-sot</code> brings a different take on the public API that users of Opaleye are encouraged to use; in particular, it makes extensive use of advanced type system features offered by <a href="http://www.haskell.org/ghc">GHC, the Glasgow Haskell Compiler</a>, so as to reduce the number scenarios that could lead to Opaleye generating <em>the wrong SQL</em>, to reduce the amount of boilerplate that one needs to write in order to make effective use of Opaleye, and to increase the readability and maintainability of queries and data types written using this API. <code>opaleye-sot</code> is an early project with not many people depending on it yet, so hopefully it will be able to evolve rapidly and function as a test bed for new features or approaches, some of which may eventually make it to <code>opaleye</code> proper, without worrying too much about backwards compatibility for now. For now, and the foreseeable future, <a href="http://www.postgresql.org/">PostgreSQL</a> is the only supported SQL backend.</p>
<p>For the rest of this article, I will assume familiarity with the basic usage of Opaleye, and build on that. Familiarity with <code>HList</code>, <code>TypeFamilies</code>, <code>GADTs</code>, <code>Arrows</code>, <code>DataKinds</code>, <code>PolyKinds</code> and <code>KindSignatures</code> will be useful too, but not required. We will cover the topic of preventing <em>the wrong SQL</em>, but first let us worry about the simpler topic of boilerplate. That is, about things we would rather not write.</p>
<h2 id="boilerplate-and-representations">Boilerplate and representations</h2>
<p>Opaleye, quite wisely, doesn’t force itself into any particular data type for the Haskell representation of SQL rows, instead it allows us to pick any representation we want as long as we can provide a <a href="https://hackage.haskell.org/package/product-profunctors-0.6.3.1/docs/Data-Profunctor-Product.html#t:ProductProfunctor"><code>ProductProfunctor</code></a> instance for it. This means, for example, that if we have a row with two fields, we can choose to represent that as any product type with two elements: be it <code>(a, b)</code>, a custom <code>Foo a b</code>, or similar. Those <code>a</code> and <code>b</code>, however, will change depending on what we are trying to accomplish. For example, assuming a SQL row with a <code>bool</code> column and a <code>text</code> column, when giving that SQL row a concrete Haskell representation we may use the type <code>Foo Bool String</code>, but when writing said SQL row to the database we will need to use <code>Foo (Column PGBool) (Column PGText)</code>. For this reason, Opaleye recommends leaving <code>a</code> and <code>b</code> polymorphic, and using type synonyms to fix <code>a</code> and <code>b</code> to particular types depending on the scenario. There is only a limited number of scenarios like these two where <code>a</code> and <code>b</code> will need to change. Personally, I think this is a good approach to working with different yet somewhat similar representations, but hopefully we all can agree that this can lead to a non-negligible amount of boilerplate, in particular when working with rows having many columns, and we need to prevent this. Our goal is to reduce the amount of boilerplate we need to write regarding these types, hopefully without resorting to the powerful but huge, fragile and uncomfortable hammer that <code>TemplateHaskell</code> can be.</p>
<p><code>opaleye-sot</code> solves this problem by using a combination of <a href="https://hackage.haskell.org/package/HList"><code>HList</code></a> (Oleg Kiselyov, Ralf Laemmel, Keean Schupke et al.) and type families which we will now analyze in detail. For those unfamiliar with with <code>HList</code>, we will start by mentioning its traditional representation using <a href="https://wiki.haskell.org/Generalised_algebraic_datatype">GADTs</a>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="fu">*</span>] <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">HNil</span><span class="ot">  ::</span> <span class="dt">HList</span> <span class="ch">&#39;[]</span>
  <span class="dt">HCons</span><span class="ot"> ::</span> x <span class="ot">-&gt;</span> <span class="dt">HList</span> xs <span class="ot">-&gt;</span> <span class="dt">HList</span> (x <span class="ch">&#39;: xs)</span></code></pre></div>
<p>That is, an <code>HList :: [*] -&gt; *</code> is analogous to <code>[] :: *</code> where the <code>HNil</code> is analogous to <code>[] :: []</code> and <code>HCons</code> is analogous to <code>(:) :: x -&gt; [x] -&gt; [x]</code>, but where each of the elements inside the successive <code>HCons</code> constructors can be of different types.</p>
<pre><code>&gt; -- This doesn&#39;t typecheck:
&gt; (:) True ((:) 42 []) :: [Bool, Int]
&gt; -- This does typecheck:
&gt; HCons True (HCons 42 HNil) :: HList &#39;[Bool, Int]</code></pre>
<p><code>HList</code> has some properties that are very interesting to us. To start with, not only we can store an arbitrary number of elements of different types, but we can also know statically—that is, at compile time—both the number and types of those elements. Moreover, that information is kept in a type-level list promoted using <code>DataKinds</code>, which means that we can manipulate that list and see it change its length and contents at compile time, just like we could do with a traditional term-level polymorphic list at runtime. And finally, <code>HList</code> can be given an instance of <code>ProductProfunctor</code> that works for lists of any length, not only making it a suitable datatype for Opaleye, but also preventing us from having to define a new <code>ProductProfunctor</code> instance for each different Haskell representation we would like to use for mapping SQL rows. For these reasons, we will use <code>HList</code> as the preferred container for all our SQL row mapping needs, which gives us a uniform way to work with different SQL rows.</p>
<p>Armed with <code>HList</code>, we can now to try map between it and an actual SQL row in different Opaleye scenarios. We will use this contrived but comprehensive SQL as example:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;public&quot;</span>.<span class="ot">&quot;user&quot;</span>
  ( <span class="ot">&quot;id&quot;</span> serial4 <span class="kw">NOT</span> <span class="kw">NULL</span>
  , <span class="ot">&quot;name&quot;</span> text <span class="kw">NOT</span> <span class="kw">NULL</span>
  , <span class="ot">&quot;favoriteNumber&quot;</span> int4 <span class="kw">NULL</span> <span class="kw">DEFAULT</span> <span class="dv">42</span>
  , <span class="ot">&quot;age&quot;</span> int4 <span class="kw">NULL</span>
  )</code></pre></div>
<p>Notice what is special about those 4 columns regarding the values they can take:</p>
<div class="table-wrapper" style="overflow-x:visible;">
<table>
<thead>
<tr class="header">
<th align="left">Column</th>
<th align="left">Can it contain <code>NULL</code>?</th>
<th align="left">Do we want <code>DEFAULT</code> to be written to it?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>id</code></td>
<td align="left">No</td>
<td align="left">Yes</td>
</tr>
<tr class="even">
<td align="left"><code>name</code></td>
<td align="left">No</td>
<td align="left">No</td>
</tr>
<tr class="odd">
<td align="left"><code>favoriteNumber</code></td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr class="even">
<td align="left"><code>age</code></td>
<td align="left">Yes</td>
<td align="left">No</td>
</tr>
</tbody>
</table>
</div>
<p>Notice how we worded our question: <em>Do we want <code>DEFAULT</code> to be written to it?</em> We put it this way because in PostgreSQL, unfortunately, even if you do not ask for a column to have a default value, <code>DEFAULT</code> can be written to it, and by default <code>DEFAULT</code> means <code>NULL</code>. That is, <code>DEFAULT</code> is at times just a different spelling for <code>NULL</code>. Later we will talk about why <code>NULL</code> is, was, and will ever be a terrible idea, but for the time being we have to acknowledge the fact that it exists and that we have to deal with it, which we will do by hiding it under a type-safe interface that will prevent this accidental meaning for <code>DEFAULT</code>. This will force us to say <code>NULL</code> if we want to say <code>NULL</code>, or to explicitly acknowledge, per column, that <code>DEFAULT</code> is an acceptable value to write to it even when it could mean <code>NULL</code>, even in columns marked <code>NOT NULL</code>. So, from now on we will ignore the fact that <code>DEFAULT</code> can be written to any column if done manually from SQL, because from within <code>opaleye-sot</code>’s DSL <code>DEFAULT</code> will only be available if we asked for it. This situation, as unfortunate as it might be, serves as a good example as what software many times is: Layers of abstraction over layers of abstraction, where each layer fixes some problems found in the layer below, allowing upper layers to be oblivious of it. Haskell, with its precise type system and functional nature, can do a great job in such scenarios.</p>
<p>In <code>opaleye-sot</code> we will also explicitly distinguish between the combinations of whether <code>NULL</code> and <code>DFAULT</code> are possible, even more so than how Opaleye does it out of the box today—although <a href="https://github.com/tomjaguarpaw/haskell-opaleye/issues/97">there are plans to improve this</a>. We will now talk about this in more detail as we try to understand all the different Opaleye scenarios in which we will be working.</p>
<h2 id="scenario-1-hsr">Scenario 1: HsR</h2>
<p class="subtitle">
Haskell values read from the database
</p>
<p>Since we are only concerned about reading from the database here, we can safely ignore the question of whether <code>DEFAULT</code> can be written to each particular column. We must worry about whether the column can contain <code>NULL</code>, however. We will represent that possibility as <code>Maybe</code>.</p>
<p>Ignoring <code>HList</code> and Opaleye for a moment, we might opt for a representation like the following one. To prevent any confusion with forthcoming examples, we will add the <code>_HsR</code> suffix to these types, meaning that this is the representation of “Haskell values read from the database”, that is, “HsR” stands for “Haskell, Read”.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">User_HsR</span> <span class="fu">=</span> <span class="dt">User_HsR</span>
  { _<span class="ot">user_HsR_id             ::</span> <span class="dt">Int32</span>
  , _<span class="ot">user_HsR_name           ::</span> <span class="dt">Text</span>
  , _<span class="ot">user_HsR_favoriteNumber ::</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>
  , _<span class="ot">user_HsR_age            ::</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>
  }</code></pre></div>
<p>Or even something like this if we are not particularly interested in the names of the columns:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR</span> <span class="fu">=</span> (<span class="dt">Int32</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">Int32</span>, <span class="dt">Maybe</span> <span class="dt">Int32</span>)</code></pre></div>
<p>With <code>HList</code> we can express this very same thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR</span> <span class="fu">=</span> <span class="dt">HList</span> <span class="ch">&#39;[Int32, Text, Maybe Int32, Maybe Int32]</span></code></pre></div>
<p>If we wanted, we could manually define field accessors similar to the ones in the example record definition for <code>User_HsR</code>, or even lenses. But alas, we don’t want to, because doing this will open a door to <em>the wrong SQL</em>. Let’s carefully think about why and analyze this bit together, because it is in small details such as this one where Haskell can go the extra mile and radically tell itself apart from other programming languages when it comes to code maintenance.</p>
<p>Can you tell the difference between these two types?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR1</span> <span class="fu">=</span> (<span class="dt">Int32</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">Int32</span>, <span class="dt">Maybe</span> <span class="dt">Int32</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR2</span> <span class="fu">=</span> (<span class="dt">Int32</span>, <span class="dt">Text</span>, <span class="dt">Maybe</span> <span class="dt">Int32</span>, <span class="dt">Maybe</span> <span class="dt">Int32</span>)</code></pre></div>
<p>What about these two?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">User_HsR1</span> <span class="fu">=</span> <span class="dt">User_HsR1</span>
  { _<span class="ot">user_HsR1_id             ::</span> <span class="dt">Int32</span>
  , _<span class="ot">user_HsR1_name           ::</span> <span class="dt">Text</span>
  , _<span class="ot">user_HsR1_favoriteNumber ::</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>
  , _<span class="ot">user_HsR1_age            ::</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>
  }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">User_HsR2</span> <span class="fu">=</span> <span class="dt">User_HsR2</span>
  { _<span class="ot">user_HsR2_id             ::</span> <span class="dt">Int32</span>
  , _<span class="ot">user_HsR2_name           ::</span> <span class="dt">Text</span>
  , _<span class="ot">user_HsR2_age            ::</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>
  , _<span class="ot">user_HsR2_favoriteNumber ::</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>
  }</code></pre></div>
<p>That’s right, the order of the two last fields was changed, but of course we didn’t notice the first time because their types were the same. And neither did the type checker. So we should ask ourselves what keeps the result of <code>SELECT id, name, favoriteNumber, age FROM user</code>, in that order, from being somehow converted into any of <code>User_HsR1</code> or <code>User_HsR2</code> above? And the answer is, of course, nothing. One day we will wake up having 12345 years of age because that was our favorite number.</p>
<p>To me, falling into traps like this one is unacceptable, even more so when working in large projects where we can’t possibly keep track of all these details, or at least where we shouldn’t need to because surely there are more important things to do. It is not our job, we have type checkers. Our job is to teach the type checker how to tell right from wrong and move on, which is not so hard if we restrict ourselves to small domains and leverage a type system as expressive as GHC’s.</p>
<p>In order to solve this, first, we need to precisely identify what we are trying to accomplish: We would like to use names to identify the particular columns in our Haskell representations for SQL rows because telling apart the meaning of <em>age</em> from the meaning of <em>favorite number</em> is much easier than telling apart the meaning of a <code>Maybe Int32</code> from the meaning of another <code>Maybe Int32</code>. Additionally, we want to be sure that every time we say <em>age</em> in our Haskell representation we do mean <em>age</em> in the SQL row too, and that we make it very hard for this property to be violated accidentally.</p>
<p>Having identified our goal, we can start working towards a solution. We might categorize the problem here as one where there is more than one source of information, that is, where both our Haskell representation and the SQL table are trying to inform us the names of the fields. But which source do we trust when they differ? Wrong, that is the wrong question. The right question to ask ourselves is how to <em>prevent</em> those two sources from ever differing. And, as it is usually the case in situations like this one, the problem is that we have two sources of information where we should have had just one.</p>
<p>If you have been building software for a while you already know that it is not truly possible for data representations existing in different realms to map perfectly with one another. That is, as an example in our case, we can’t expect that a Haskell data type that today maps perfectly to a SQL row will continue to do so after any of the two is modified. Nevertheless, if we are careful when we design said representations and their usage, we can ensure that our software is resilient to future compatible changes, and that incompatible changes don’t go unnoticed.</p>
<p>What we will do is define the names of the columns just once <em>in the type system</em>, and then, every time we need to refer to a particular column—be it for selecting it, updating it, showing its name in some debugging tool or something else—we will refer to its type. And only then, maybe, convert said type to a term if at all needed. Additionally, we will never refer to columns by their position in a row, only by its name.</p>
<p>The names of PostgreSQL tables can be expressed as Haskell values of type <code>String</code>. In GHC, values of type <code>String</code> can have a type-level representation as a type of kind <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-TypeLits.html#t:Symbol"><code>Symbol</code></a>s, which can trivially be converted back to <code>String</code>s at runtime—and with some caveats, also <code>String</code>s can be converted to <code>Symbol</code>s, but we are not particularly interested in this last conversion today.</p>
<p>If you are unfamiliar with kinds, can think of them as “the types of types”. Every type that has a term level representation (e.g., <code>Int</code>, <code>Bool</code>, <code>Maybe Double</code>, etc.) has a kind named <code>*</code> (yes, <code>*</code>, that is the name). Type-level strings don’t have a term-level representation, so its kind can be something else: <code>Symbol</code> in this case. Conversion between a type-level string and a term-level string is made explicitly via <code>symbolVal</code>. Here’s a GHCi session demonstrating the usage of <code>Symbol</code> and kinds.</p>
<pre><code>&gt; :set -XDataKinds
&gt; :set -XKindSignatures
&gt; import Data.Proxy
&gt; import GHC.TypeLits
&gt; :type (&quot;hello&quot; :: (String :: *))
(&quot;hello&quot; :: (String :: *)) :: String
&gt; :kind (&quot;hello&quot; :: Symbol)
(&quot;hello&quot; :: Symbol) :: Symbol
&gt; :type (symbolVal (Proxy :: Proxy (&quot;hello&quot; :: Symbol)) :: (String :: *))
(symbolVal (Proxy :: Proxy (&quot;hello&quot; :: Symbol)) :: (String :: *))
&gt; symbolVal (Proxy :: Proxy (&quot;hello&quot; :: Symbol)) :: (String :: *)
&quot;hello&quot;</code></pre>
<p>Terms, types and kinds: Make sure you understand the difference between them <a href="https://typesandkinds.wordpress.com/2015/08/19/planned-change-to-ghc-merging-types-and-kinds/">at least for a while</a>.</p>
<p>With this new tool we can modify our <code>HList</code> solution from before so that not only it mentions the type of the value contained in each particular column, but also the name of the column itself, so that if we ever mistype the name of a column the type checker will let us now. For this, we will use the <code>Tagged</code> data type, yet another very simple but very powerful tool for teaching our type checker how to tell right from wrong.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Tagged</span> (<span class="ot">t ::</span> k) a <span class="fu">=</span> <span class="dt">Tagged</span> a</code></pre></div>
<p>Remember, what is mentioned to the left of the <code>=</code> exists on the type level and can be known statically at compile time, and what is mentioned to its right exists on the term level and can be known at runtime. In other words, <code>t</code> needs not have an accompanying term of type <code>t</code>, and there is nothing in the <code>Tagged</code> constructor that restricts <code>t</code> to be some particular type nor of a particular kind (as witnessed by the polymorphic kind <code>k</code>). A type like <code>t</code> which apparently serves no purpose is called a <a href="http://www.haskell.org/haskellwiki/Phantom_type">panthom type</a>, and we have seen this kind of type before when we used <code>Proxy</code> in the previous example.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> (<span class="ot">t ::</span> k) <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>Look at that. <code>Proxy</code> seems to be even more useless than <code>Tagged</code>, it carries no information whatsoever at the term-level. But the thing is, <code>Proxy</code> is a tool for programming at the type-level, not at the term-level, so that is perfectly fine. When we used <code>Proxy</code> before in our <code>symbolVal</code> example, we weren’t interested in any term-level value. We couldn’t possibly have been, because as we said before, type-level strings do not exist at the term-level; if they existed their kind would have been <code>*</code>, but alas, it is <code>Symbol</code>. Nevertheless, <a href="https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-TypeLits.html#v:symbolVal"><code>symbolVal</code></a>, a class method that exists at the term-level, needs to somehow receive as a term-level argument a type-level string so that it can dispatch to the appropriate <code>KnownSymbol</code> instance. <code>Proxy</code> is simply a bridge that connects the type-level world with the term-level world.</p>
<p>Now that we have learned about <code>Proxy</code>, there is not much to say about <code>Tagged</code> beyond the fact that it is isomorphic to <code>(Proxy t, a)</code>. That is, not only it carries some type-level value <code>t</code>, but also a plain old term-level value <code>a</code>. With <code>Tagged</code> we could write hypothetical functions such as this:</p>
<pre><code>callFrenchPhone :: Tagged France PhoneNumber -&gt; IO CallInformation</code></pre>
<p>Here, the type-checker will ensure that only <code>PhoneNumbers</code> tagged with <code>France</code> can be called using the <code>callFrenchPhone</code> function:</p>
<pre><code>&gt; -- This typechecks:
&gt; callFrenchPhone (... :: Tagged France PhoneNumber)
&gt; -- This doesn&#39;t typecheck:
&gt; callFrenchPhone (... :: Tagged India PhoneNumber)</code></pre>
<p>It is worth noting that the benefits we get from <code>Tagged French PhoneNumber</code> are not so different from the benefits we get from introducing a <code>newtype</code> like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FrenchPhoneNumber</span> <span class="fu">=</span> <span class="dt">FrenchPhoneNumber</span> <span class="dt">PhoneNumber</span></code></pre></div>
<p>Nevertheless, <code>Tagged t a</code> is at times more convenient and uniform to use than the <code>newtype</code> solution, and it can also be used for <code>t</code> s that may not be yet known at compile time.</p>
<p>Putting together our new knowledge of <code>Tagged</code>, <code>Symbol</code> and we learned about <code>HList</code>, this is what we end up with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR</span> <span class="fu">=</span> <span class="dt">HList</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot; Int32</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span> <span class="dt">Text</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   ]</code></pre></div>
<p>Perfect. Now the type of the Haskell representation for a value in a column (e.g., <code>Text</code>) will always be accompanied by the name of its column at the type-level (e.g., <code>&quot;name&quot;</code>). Just one last detail: The <code>HList</code> library we are using provides a variant to <code>HList</code> named <a href="https://hackage.haskell.org/package/HList-0.4.1.0/docs/Data-HList-Record.html"><code>Record</code></a> which has an API specially designed for working with <code>HList</code>s whose elements are <code>Tagged</code> values, just like here. From here on we will use <code>Record</code> instead of <code>HList</code> due to the convenience of this API, but other than that, there is no fundamental difference between an <code>HList</code> and a <code>Record</code>. So, our final <code>User_HsR</code>, at least for now, is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot; Int32</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span> <span class="dt">Text</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   ]</code></pre></div>
<h2 id="scenario-2-maybe-hsr">Scenario 2: Maybe HsR</h2>
<p class="subtitle">
Possibly missing Haskell values read from the database
</p>
<p>Even while <code>User_HsR</code> is a perfectly acceptable Haskell representation for SQL rows coming out of the database, sometimes those rows will be empty, such as in the case of a missing right hand side in a <code>LEFT JOIN</code>. For those cases, <code>Maybe User_HsR</code> will be a perfectly acceptable type within <code>opaleye-sot</code>. A variant of <code>User_HsR</code> where each column is wrapped in <code>Maybe</code> is acceptable too, but often less practical.</p>
<h2 id="scenario-3-hsi-haskell-values-to-be-inserted-to-the-database">Scenario 3: HsI, Haskell values to be inserted to the database</h2>
<p class="subtitle">
Haskell values to be inserted to the database
</p>
<p>In this scenario the types are mostly like those in the HsR scenario, but we also want to consider that some columns can take a <code>DEFAULT</code> value when being written to. In our case, the columns <code>id</code> and <code>favoriteNumber</code>. We will simply wrap with <code>WDef</code> the types of the elements representing those columns in our <code>Record</code>. <code>WDef</code> is defined like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">WDef</span> a <span class="fu">=</span> <span class="dt">WDef</span> <span class="fu">|</span> <span class="dt">WVal</span> a</code></pre></div>
<p>The idea is that if you want to write a specific value to a column you wrap it in the <code>WVal</code> constructor, otherwise you use the <code>WDef</code> constructor and <code>opaleye-sot</code> will replace that with <code>DEFAULT</code> in the generated SQL.</p>
<p>With this in place, we can proceed to define our counterpart to <code>User_HsR</code> containing Haskell values to be inserted to the database in a particular SQL row, which we will call <code>User_HsI</code>, short for “Haskell, insert”.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsI</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot; (WDef Int32)</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span> <span class="dt">Text</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">WDef</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>))
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   ]</code></pre></div>
<p>You may have noticed that <code>WDef</code> is isomorphic to <code>Maybe</code>, and that we might as well have used <code>Nothing</code> to signify that we want to write <code>DEFAULT</code> to a column, and <code>Just</code> otherwise. So, why didn’t we do that? Why did we introduce a whole new type just for this? We did it because, again, this is a situation where by carefully paying attention just once, we can forever profit from preventing more of <em>the wrong SQL</em>.</p>
<p>Let’s pay attention to the <code>favoriteNumber</code> column. Not only it can take a <code>DEFAULT</code> value when being written to, but it can also contain a Haskell representation for <code>NULL</code> as <code>Nothing</code>. If we had used <code>Maybe</code> instead of <code>WDef</code>, then the type of the column—ignoring the <code>Tagged</code> wrapper—would have been <code>Maybe (Maybe Int32)</code>, and there are important problems with that. The first one is that it is not obvious what each of the <code>Maybe</code>s mean anymore: Was it the outer or the inner <code>Maybe</code> the one signifying <code>DEFAULT</code>? And which one signified <code>NULL</code>? The answer is not obvious. Moreover, if we had used <code>Maybe</code> instead of <code>WDef</code>, the meaning of the <code>Maybe</code>s in the columns <code>id</code> and <code>age</code> would have been completely ambiguous; we couldn’t possibly know if a <code>Nothing</code> value in those columns meant <code>DEFAULT</code> or <code>NULL</code>. But besides all this, and not at all obvious and much more interesting to us, is the fact that both <code>Nothing</code> and <code>Just Nothing</code> are valid values for the type <code>Maybe (Maybe Int32)</code>, which means that mistaking one for the other would go completely unnoticed by the type checker, quite possibly leading us to <em>the wrong SQL</em>. By making the distinction between <code>WDef</code> and <code>Maybe</code> explicit we have taught the type-checker to tell right from wrong once again.</p>
<h2 id="the-billion-dollar-mistake">The billion dollar mistake</h2>
<div class="epigraph">
<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<footer>
Tony Hoare, 2009.
</footer>
</blockquote>
</div>
<p>SQL, as most other programming languages out there, is happy to take <code>NULL</code> anywhere an expression of a specific type is expected, effectively subverting any type-system guarantees—much like <code>undefined</code> in Haskell, which one does not use, recommend, nor talk about. In SQL, <code>NULL</code> is particularly noteworthy because we don’t always find the world modeled in <a href="https://en.wikipedia.org/wiki/Sixth_normal_form">Sixth Normal Form</a>. Instead, tables are bound to have missing data, which is most often represented as <code>NULL</code>.</p>
<p>Once we acknowledge the fact that <code>NULL</code> will stay in <code>SQL</code> for a while, and that we have no idea whether <code>SELECT (x :: bool) AND (y :: bool) FROM t</code> even results in a <code>bool</code> value, then we need to learn how to deal with it. But not from scratch, because in Haskell we already know how to deal with <code>NULL</code> by means of <code>Maybe</code> and we can leverage that knowledge.</p>
<p>Most times, if we want to make something useful with a value of type <code>Maybe a</code>, at some point we will probably need to understand what is <code>a</code> and how to use it. For example, if we want to <code>fmap</code> some function <code>a -&gt; b</code> over <code>Maybe a</code>, then we need to make a choice about what that <code>a</code> is, or at least which constraints it satisfies. We could say we expect to have a <code>Maybe Int</code>, or a <code>Maybe Bool</code> or even a <code>Num a =&gt; Maybe a</code>. The important thing to notice is that the <code>a</code> in <code>Maybe a</code> must be a type with a term-level representation that exists in memory Haskell at runtime. But when using Opaleye to generate SQL queries, we are not dealing with Haskell values that exist in memory in the Haskell runtime at the very same moment when when the SQL is being generated. In Opaleye, when you have a <code>Column PGBool</code>, that is just a promise that if the generated SQL is ever run, wherever it runs, the type of a specific column inside the PostgreSQL database will be of type <code>bool</code> (with the caveat that it might contain a <code>NULL</code> value), but there is no way to directly manipulate a term-level representation for said <code>PGBool</code> in Haskell like we could manipulate an <code>Int</code>, a <code>Bool</code> or <code>()</code>. Much like the <code>t</code> in <code>Tagged t a</code>, <code>PGBool</code> and similar types exist only at the type-level, they have no term-level representation in Haskell at runtime. In fact, since these types have no term-level representation, they could have had a kind different from <code>*</code>, but for reasons beyond the scope of this article <code>*</code> works better when you have to assume an open world, so you will find that <code>PGBool</code> and similar have kind <code>*</code>.</p>
<p>What we need, and what <code>opaleye-sot</code> offers, is a <code>Maybe</code>-like type that can be used in Opaleye’s query language and can’t possibly be mixed with a non-<code>Maybe</code>-like type. Much like how the type-checker keeps us from multiplying an <code>Int</code> by a <code>Maybe Int</code>, we want the type-checker to prevent us from multiplying a <code>PGInt4</code> by a <code>PGInt4</code> that may be <code>NULL</code> unless we explicitly deal with the fact that said possibility exists. In <code>opaleye-sot</code>, we call this type <code>Koln</code>, short for “Column, nullable”, but with a “K” instead of a “C” to avoid any potential confusion with Opaleye’s <code>Column</code>. A type like <code>Koln PGBool</code> is basically Opaleye’s <code>Column (Nullable PGBool)</code>. As I said before, <a href="https://github.com/tomjaguarpaw/haskell-opaleye/issues/97">there are plans</a> to implement this idea in Opaleye proper, but for the time being this is only available in <code>opaleye-sot</code>.</p>
<p>Now that we have a precise Haskell representation for the description of a possible <code>NULL</code> value in a PostgreSQL column, we can deploy the whole <code>Maybe</code> toolset we Haskellers have grown to be so fond of:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Like &#39;maybe&#39;. Case analysis for &#39;Koln&#39;.</span>
<span class="fu">--</span>
<span class="co">-- If &#39;Koln a&#39; is &#39;NULL&#39;, then evaluate to the first argument,</span>
<span class="co">-- otherwise it applies the given function to the underlying &#39;Kol a&#39;.</span>
<span class="ot">matchKoln ::</span> <span class="dt">Kol</span> b <span class="ot">-&gt;</span> (<span class="dt">Kol</span> a <span class="ot">-&gt;</span> <span class="dt">Kol</span> b) <span class="ot">-&gt;</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Kol</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Like &#39;fmap&#39; for &#39;Maybe&#39;.</span>
<span class="fu">--</span>
<span class="co">-- Apply the given function to the underlying &#39;Kol a&#39; only as long as the</span>
<span class="co">-- given &#39;Koln a&#39; is not &#39;NULL&#39;, otherwise, evaluates to &#39;NULL&#39;.</span>
<span class="ot">mapKoln ::</span> (<span class="dt">Kol</span> a <span class="ot">-&gt;</span> <span class="dt">Kol</span> b) <span class="ot">-&gt;</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Monadic bind like the one for &#39;Maybe&#39;.</span>
<span class="fu">--</span>
<span class="co">-- Apply the given function to the underlying &#39;Kol a&#39; only as long as the</span>
<span class="co">-- given &#39;Koln a&#39; is not &#39;NULL&#39;, otherwise, evaluates to &#39;NULL&#39;.</span>
<span class="ot">bindKoln ::</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> (<span class="dt">Kol</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> b) <span class="ot">-&gt;</span> <span class="dt">Koln</span> b</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Like &#39;(&lt;|&gt;) :: Maybe a -&gt; Maybe a -&gt; Maybe a&#39;.</span>
<span class="fu">--</span>
<span class="co">-- Evaluates to the first argument if it is not &#39;NULL&#39;, otherwise</span>
<span class="co">-- evaluates to the second argument.</span>
<span class="ot">altKoln ::</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> a</code></pre></div>
<p>With these tools we are can now reason in terms of <code>Maybe</code>, <code>Functor</code>s, <code>Monad</code>s and <code>Alternative</code>s <em>in the SQL expresions themselves</em>, not just in the Opaleye query language, and suddenly SQL doesn’t look so bad anymore. The definitions of those functions are not important, but you might check the source code if you are curious. What is important is to understand the difference between <code>Kol a</code> and <code>Koln a</code>. Whereas <code>Koln a</code> explicitly informs us that said <code>a</code> might be <code>NULL</code>, and that we must explicitly deal with that possibility, <code>Kol a</code> tells us that <code>a</code> can’t possibly be <code>NULL</code>. Or, in another words, <code>Koln a</code> is analogous to <code>Maybe a</code> while <code>Kol a</code> is analogous to <code>Identity a</code>, and we now that <code>a</code> and <code>Identity a</code> are isomorphic. So, rewriting some well-known Haskell functions to use <code>Identity</code> and following these analogies, we end up with this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">matchKoln
<span class="ot">  ::</span> <span class="dt">Kol</span> b <span class="ot">-&gt;</span> (<span class="dt">Kol</span> a <span class="ot">-&gt;</span> <span class="dt">Kol</span> b) <span class="ot">-&gt;</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Kol</span> b
<span class="co">-- &#39;Identity x&#39; is analogous to &#39;Kol x&#39;, &#39;Maybe x&#39; is analogous to &#39;Koln x&#39;</span>
<span class="ot">  ::</span> <span class="dt">Identity</span> b <span class="ot">-&gt;</span> (<span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b
<span class="co">-- &#39;x&#39; is isomorphic to &#39;Identity x&#39;</span>
<span class="ot">  ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b
<span class="co">-- We reached the type of `maybe`</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mapKoln
<span class="ot">  ::</span> (<span class="dt">Kol</span> a <span class="ot">-&gt;</span> <span class="dt">Kol</span> b) <span class="ot">-&gt;</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> b
<span class="co">-- &#39;Identity x&#39; is analogous to &#39;Kol x&#39;, &#39;Maybe x&#39; is analogous to &#39;Koln x&#39;</span>
<span class="ot">  ::</span> (<span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="co">-- &#39;x&#39; is isomorphic to &#39;Identity x&#39;</span>
<span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="co">-- We reached the type of `fmap` for &#39;Maybe&#39;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bindKoln
<span class="ot">  ::</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> (<span class="dt">Kol</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> b) <span class="ot">-&gt;</span> <span class="dt">Koln</span> b
<span class="co">-- &#39;Identity x&#39; is analogous to &#39;Kol x&#39;, &#39;Maybe x&#39; is analogous to &#39;Koln x&#39;</span>
<span class="ot">  ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (<span class="dt">Identity</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="co">-- &#39;x&#39; is isomorphic to &#39;Identity x&#39;</span>
<span class="ot">  ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b
<span class="co">-- We reached the type of &#39;(&gt;&gt;=)&#39; for &#39;Maybe&#39;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">altKoln
<span class="ot">  ::</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> a <span class="ot">-&gt;</span> <span class="dt">Koln</span> a
<span class="co">-- &#39;Identity x&#39; is analogous to &#39;Kol x&#39;, &#39;Maybe x&#39; is analogous to &#39;Koln x&#39;</span>
<span class="ot">  ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
<span class="co">-- We reached the type of &#39;(&lt;|&gt;)&#39; for &#39;Maybe&#39;</span></code></pre></div>
<p>Opaleye, as of today, offers <code>Column a</code> and <code>Column (Nullable a)</code> as counterparts to <code>Kol a</code> and <code>Koln a</code>. What is so special about <code>Kol a</code> is that it makes it explicit that said <code>a</code> may never be <code>Nullable</code>. That’s all there is to it really. Of course there are ways to convert between <code>Column</code>, <code>Kol</code> and <code>Koln</code> by means of <code>kol</code>, <code>unKol</code>, <code>koln</code> and <code>unKoln</code> so that <code>opaleye-sot</code> code can readily compose with <code>opaleye</code> code using <code>Column</code>. Hopefully this explicit difference will exist in <code>opaleye</code> proper soon.</p>
<h2 id="scenario-4-pgr">Scenario 4: PgR</h2>
<p class="subtitle">
PostgreSQL values read in the database
</p>
<p>Now that we understand <code>Kol</code> and <code>Koln</code>, we can proceed to give a Haskell representation to the PostgreSQL counterpart of <code>User_HsR</code>. We will call it <code>User_PgR</code> where “PgR” stands for “PostgreSQL, read”.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_PgR</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot; (Kol PGInt4)</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span> (<span class="dt">Kol</span> <span class="dt">PGText</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   ]</code></pre></div>
<p>There is nothing fundamentally new here. We simply started from <code>User_HsR</code>, replaced <code>Int32</code> and <code>Text</code> for their PostgreSQL counterparts <code>PGInt4</code> and <code>PGText</code>, and then applied the same isomorphisms and analogies we applied before when comparing <code>maybe</code> to <code>matchKoln</code> or <code>fmap</code> to <code>mapKoln</code>.</p>
<p><code>User_PgR</code> is the type that we will use when writing queries using Opaleye’s query language, it is our Haskell representation of a SQL row that doesn’t exists in the Haskell runtime but in the PostgreSQL database. <code>User_PgR</code> is to <code>User_HsR</code> what <code>Kol</code> is to <code>Identity</code> or <code>Koln</code> is to <code>Maybe</code>.</p>
<h2 id="scenario-5-pgrn">Scenario 5: PgRN</h2>
<p class="subtitle">
Possibly missing PostgreSQL values read in the database
</p>
<p>Just like we needed <code>Maybe User_HsR</code> to interpret the result of the missing right hand side of a <code>LEFT JOIN</code> in Haskell, we need something similar for the PostgreSQL side of things.</p>
<p>Like we said, a valid alternative to <code>Maybe User_HsR</code> is a variant of <code>User_HsR</code> where each of the column types is wrapped in <code>Maybe</code>, signifying as expected that each column can be <code>NULL</code>. So, it shouldn’t be surprising by now that what we need is an analogy to that representation but using <code>Koln</code> instead of <code>Maybe</code>.</p>
<p>Without further ado, we take <code>User_PgR</code>, wrap each column type in <code>Koln</code>, and name the result <code>User_PgRN</code>, meaning “PostgreSQL, read, nullable”.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_PgRN</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot; (Koln PGInt4)</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGText</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   ]</code></pre></div>
<p>Notice that if we would have blindly “wrapped” the last two columns with <code>Koln</code> we would have ended with <code>Koln (Koln PGInt4)</code> in each of them, which doesn’t work as <code>Koln</code> expects that its argument is one of <code>PGInt4</code>, <code>PGBool</code>, etc. So we simply flattened the two redundant <code>Koln</code> layers into one, which is semantically the same. In other words, only columns that were <code>Kol</code> in <code>User_PgR</code> need to be changed to <code>Koln</code> in <code>User_PgRN</code>, the others remain the same.</p>
<h2 id="scenario-6-pgw">Scenario 6: PgW</h2>
<p class="subtitle">
PostgreSQL values to be written to the database
</p>
<p>Finally, our last scenario. Just like <code>User_PgR</code> was the PostgreSQL counterpart to <code>User_HsR</code>, <code>User_PgW</code> here will be the PostgreSQL counterpart to <code>User_HsI</code>, except not only will it be used when inserting new values, but also when updating them. Following our nomenclature, “PgW” stands for “PostgreSQL, write”.</p>
<p>Just like we did for <code>User_HsI</code>, where we started from <code>User_HsR</code> and added the <code>WDef</code> wrappers where necessary, here we will start from <code>User_PgR</code> and do the same, meaning that when inserting or updating a row in the database we can set its value to <code>DEFAULT</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_PgW</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot; (WDef (Kol PGInt4))</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span> (<span class="dt">Kol</span> <span class="dt">PGText</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">WDef</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>))
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   ]</code></pre></div>
<p>And with this we complete our understanding of what is needed to fully leverage Opaleye using our <code>Record</code> representations. Next we will learn how to delegate that knowledge to the type system so that we can forget about the details and concentrate on more important things such as writing the actual SQL queries.</p>
<h2 id="single-representation-for-all-scenarios">Single representation for all scenarios</h2>
<p>A while ago I talked about how Opaleye encouraged us to define polymorphic types such as <code>data Foo a b = Foo a b</code> and then fixing <code>a</code> and <code>b</code> to be concrete types depending on the scenario, as opposed to fixing <code>a</code> and <code>b</code> beforehand as we did for <code>User_HsR</code>, <code>User_HsI</code>, etc. We will now move towards that representation, except we will not be specifying the <code>a</code>s and <code>b</code>s manually each time.</p>
<p>First, let’s try to understand precisely the problem we are trying to solve. Notice how if we put all of our scenarios side by side, we can easily recognize a shape demanding to be made polymorphic:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsR</span> <span class="fu">=</span> <span class="dt">HList</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             Int32</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           <span class="dt">Text</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_HsI</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             (WDef Int32)</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           <span class="dt">Text</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">WDef</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>))
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            (<span class="dt">Maybe</span> <span class="dt">Int32</span>)
   ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_PgR</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             (Kol PGInt4)</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           (<span class="dt">Kol</span> <span class="dt">PGText</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_PgRN</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             (Koln PGInt4)</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           (<span class="dt">Koln</span> <span class="dt">PGText</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User_PgW</span> <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             (WDef (Kol PGInt4))</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           (<span class="dt">Kol</span> <span class="dt">PGText</span>)
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> (<span class="dt">WDef</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>))
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   ]</code></pre></div>
<p>For now, we will work with the least polymorphic shape that can serve all such types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User</span> a b c d <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             a</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           b
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> c
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            d
   ]</code></pre></div>
<p>Our goal is to somehow have <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> fixed to the expected types depending on the scenario, but we definitely do not want to do that by hand. For this we will rely on the <code>TypeFamilies</code> GHC language extension, which among other things, allows us to write functions on types akin to functions on terms. That is, if a term-level function <code>f :: a -&gt; b</code> takes a term of type <code>a</code> to a term of type <code>b</code>, then its counterpart type-level function <code>F :: a -&gt; b</code> takes a type of kind <code>a</code> to a type of kind <code>b</code>. Take as example the function <code>fst</code>, which gives us the first element in a pair of terms:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fst<span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a
fst (a, b) <span class="fu">=</span> a</code></pre></div>
<p>We can promote the term-level function <code>fst :: (a, b) -&gt; a</code> to a type-level function <code>Fst :: (a, b) -&gt; a</code> which gives us the first element in a pair of types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Fst</span> (<span class="ot">x ::</span> (a, b))<span class="ot"> ::</span> a <span class="kw">where</span>
  <span class="dt">Fst</span> <span class="ch">&#39;(a, b) = a</span></code></pre></div>
<p>Other that the syntax here being a bit noisier, <code>Fst</code> has the expected kind and behavior, as we can see in GHCi:</p>
<pre><code>&gt; :kind Fst
Fst :: (a, b) -&gt; a
&gt; :kind &#39;(Int, &quot;hello&quot;)
&#39;(Int, &quot;hello&quot;) :: (*, Symbol)
&gt; :kind! Fst &#39;(Int, &quot;hello&quot;)
Fst &#39;(Int, &quot;hello&quot;) :: *
= Int
&gt; :type 4 :: Fst &#39;(Int, &quot;hello&quot;)
4 :: Fst &#39;(Int, &quot;hello&quot;) :: Int
&gt; 4 :: Fst &#39;(Int, &quot;hello&quot;)
4</code></pre>
<p>There are two non obvious additional properties of type-level functions that are worth mentioning and further tell them apart from type synonyms. First, just like in normal term-level functions, there can be more than one pattern on the left hand side of the function definition, and second, the expression on the right hand side need not be present on the left hand side. Take for example the following type-level function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Bar</span> (<span class="ot">x ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Bar</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Bool</span>
  <span class="dt">Bar</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Double</span></code></pre></div>
<p><code>Bool</code> and <code>Double</code>, seemingly, come out of the blue. The kind of <code>Bar</code> is <code>* -&gt; *</code>, and it is defined for both <code>Int</code> and <code>Char</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">Bar</span>
<span class="dt">Bar</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Bar</span> <span class="dt">Int</span>
<span class="dt">Bar</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">Bool</span>
<span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Bar</span> <span class="dt">Char</span>
<span class="dt">Bar</span> <span class="dt">Char</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">Double</span></code></pre></div>
<p>For other types, it is not:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>kind<span class="fu">!</span> <span class="dt">Bar</span> <span class="dt">Bool</span>
<span class="dt">Bar</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="fu">*</span>
<span class="fu">=</span> <span class="dt">Bar</span> <span class="dt">Bool</span></code></pre></div>
<p>Unfortunately GHCi doesn’t complain here that this type-level function is undefined, presumably because we are not applying its type to any term-level expression so there is nothing to type-check yet, but in any case we get a hint that this type won’t get us anywhere by noticing that <code>Bar Bool</code> is not being reduced to another type, such as it did previously in GHCi when <code>Bar Int</code> was reduced to <code>Bool</code> and <code>Bar Char</code> was reduced to <code>Double</code>. In any case, the type-checker will fail to compile a program that tries to assign the type <code>Bar Bool</code> to an expression. It can be useful to keep these things in mind when working with type-level functions like these.</p>
<p>If we look at type-level functions more generally, we should notice that only few aspects of them are new to us here, as from day one when programming in Haskell we are exposed to type-level functions in the form of type constructors like <code>Maybe :: * -&gt; *</code>, <code>[] :: * -&gt; *</code> or <code>Either :: * -&gt; * -&gt; *</code>. Everything we learned about using type-level functions applies to type constructors too. Of particular interest to us now are the type constructors <code>Tagged :: * -&gt; * -&gt; *</code> and <code>Record :: [*] -&gt; *</code> which we are using in our polymorphic definition of <code>User</code>. Let’s try to decompose our polymorphic <code>User</code> a bit more.</p>
<p>When we came up with our last definition of <code>User</code>, we said that it was the least polymorphic version of the general shape of all our <code>User</code> variants, somewhat implying that there existed more polymorphic versions of this shape, and indeed they do. Gently, we will start to decompose this even further so as to understand how to build a <code>Record</code> like this one out of the essential parts that describe a row in the <code>user</code> SQL table. Which are those essential parts? They are the ones mattered until now, and not one more. We can be certain of this, because guided by the types, we carefully analyzed each of the Opaleye scenarios we needed to cover, and only made as few changes as necessary in order to satisfy our precise requirements. Namely, for each column in our SQL row we need to know:</p>
<ol style="list-style-type: decimal">
<li><p>The name of the column.</p></li>
<li><p>Whether <code>DEFAULT</code> can be written to the column.</p></li>
<li><p>Whether the column can contain <code>NULL</code>.</p></li>
<li><p>The type of the Opaleye query language representation for value in the column when in the PostgreSQL runtime (e.g., <code>PGInt4</code>, <code>PGBool</code>).</p></li>
<li><p>The type of a value in the column when in the Haskell runtime (e.g., <code>Int</code>, <code>Bool</code>).</p></li>
</ol>
<p>We can prove that these are our essentials by showing that each of them is necessary to derive at least one of the <code>User</code> variants we need for our Opaleye scenarios, and by noting that not one of them can be derived from the others. To recapitulate: All of our scenarios need to know about the names of the columns, that is, about the essential we numbered 1 above; apart from that, the <code>HsR</code> scenario needs to know about essentials 3 and 5; the <code>HsI</code> scenario needs to know about essentials 2, 3 and 5; the <code>PgR</code> and <code>PgRN</code> scenarios need to know about essentials 3 and 4, and the <code>PgW</code> scenario needs to know about essentials 2, 3 and 4.</p>
<p>With this new certainty in mind, let’s create a type that will hold this essential information for us at the type level.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Col</span> name wd rn pg hs
   <span class="fu">=</span> <span class="dt">Col</span> name wd rn pg hs</code></pre></div>
<p><code>Col</code> might look a bit funny, different to what you would be expecting to see if this was a type intended to be used at the term-level. We will use <code>Col</code> as a promoted datatype, meaning that everything to the left of the <code>=</code> will exist as kinds, and everything to the right of the <code>=</code> will exist as types. Unfortunately, we have to repeat on the kind side each of the type variables present in the type because otherwise we can’t fix these type variables to be of a particular kind due to limitations of the <code>data</code> construct. That is, we can write something like <code>data Foo = Foo String Int</code>, but we can’t write <code>data Bar = Bar * Symbol *</code>, for example. We will expect a well-formed <code>Col</code> to have the kind <code>Col Symbol WD RN * *</code>, soon we will see what that means. Luckily for the users of <code>opaleye-sot</code> this verbose kind is mostly used internally, and it is not something they really have to worry about.</p>
<p>It is worth mentioning that some of these uncomfortable details that arise when using kinds will improve as Richard Eisenberg’s work towards a <a href="https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell">dependently typed Haskell</a> advances, but we are not there yet.</p>
<p><code>Col Symbol WD RN * *</code> simply mentions the five essentials about a column which we enumerated before. The first argument to <code>Col</code>, <code>Symbol</code>, mentions its name. The second argument, <code>WD</code>, is isomorphic to <code>Bool</code> and describes whether <code>DEFAULT</code> can be written to this column.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">WD</span> <span class="fu">=</span> <span class="dt">W</span>  <span class="co">-- ^ Write a specific value.</span>
        <span class="fu">|</span> <span class="dt">WD</span> <span class="co">-- ^ Possibly write &#39;DEFAULT&#39;. See &#39;WDef&#39;.</span></code></pre></div>
<p>We can justify rolling our own type instead of reusing <code>Bool</code> by reviewing some of the reasons that led us to use <code>WDef</code> instead of <code>Maybe</code> a while ago: We are trying to have the type-checker do as much work for us as possible, and we are trying to make it obvious for users of <code>WD</code> to understand its meaning. These days, the meaning of <code>Bool</code> is overrated, and in most cases it can be considered a sign of poor programming. Think about it this way: We reach a road junction and have to decide whether to take the road going north or the road going east. We ask a group of people passing by which road to take and they answer <code>False</code>. They tell us that they clearly remember <code>False</code> being the answer because a while ago they heard a wise man say it, but unfortunately, they didn’t hear the question well, so they don’t know if <code>False</code> was the answer to “should I go north?” or to “should I go east?”. And now we are stuck there not knowing where to go. In most situations, <code>Bool</code> doesn’t carry any meaning with it, and we can’t possibly learn about that meaning without first knowing the question being asked. In our <code>WD</code> type we fix this issue by giving a precise meaning to each of its constructors: wherever you see the <code>WD</code> constructor you know it means that <code>DEFAULT</code> can be written, and wherever you see the <code>W</code> constructor it means otherwise. Furthermore, as the question is now embedded in the answer, we are now safe from accidentally answering the wrong question.</p>
<p>The next argument to <code>Col</code> is <code>RN</code>, which describes whether a <code>NULL</code> value may be present in our column or not. <code>RN</code> follows the same reasoning as <code>WD</code>. Notice how we can’t possibly mistake <code>RN</code> for <code>WD</code> even if we forget the order in which they are presented as arguments to <code>Col</code>, which is something we couldn’t have prevented had we used <code>Bool</code> for both fields.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">RN</span> <span class="fu">=</span> <span class="dt">R</span>  <span class="co">-- ^ Read plain value.</span>
        <span class="fu">|</span> <span class="dt">RN</span> <span class="co">-- ^ Possibly read @NULL@.</span></code></pre></div>
<p>There is not much to say about the next two arguments. One of them tells the type that the value in this column will take when treated as a Haskell value, and the other tells the type it will have when treated as a placeholder, in Opaleye queries, for a value existing inside the PostgreSQL database. Since both of them share the same kind <code>*</code>, at fist it seems that we could accidentally mix and the other and it would go unnoticed. And that is true. However, <code>Col</code> will not stand on its own, instead it will be present in a larger structure we haven’t learned about yet, and this structure will further constraint <code>Col</code> so that we get an early type-checker complaint if we make this mistake. Nevertheless, even without that additional check, we know that the type we will use as a representation for the PostgreSQL type of this column will exists only at the type-level, while the type for the Haskell representation of the value in this column will be used both at the type-level and the term-level. That is, sooner or later, the type-checker will complain if we use the wrong type at the wrong place within our expected scenarios.</p>
<p>Having understood <code>Col</code>, we can proceed to demonstrate how it can be used to describe the columns in our <code>user</code> table:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ch">&#39;Col &quot;id&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;R PGInt4 Int32</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ch">&#39;Col &quot;name&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;R PGText Text</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ch">&#39;Col &quot;favoriteNumber&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN PGInt4 Int32</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ch">&#39;Col &quot;age&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;RN PGInt4 Int32</span></code></pre></div>
<p>Notice the <code>'</code> before some of the constructors. This is important when using <code>DataKinds</code>, as it helps differentiate a term-level constructor from a type-level constructor.</p>
<p>And as we know, the four of these <code>Col</code>s share the same kind, so they might as well be put together in some polymorphic container such as a type-level list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ch">&#39;[ &#39;</span><span class="dt">Col</span> <span class="st">&quot;id&quot;</span> <span class="ch">&#39;WD &#39;</span><span class="dt">R</span> <span class="dt">PGInt4</span> <span class="dt">Int32</span>
 , <span class="ch">&#39;Col &quot;name&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;R PGText Text</span>
 , <span class="ch">&#39;Col &quot;favoriteNumber&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN PGInt4 Int32</span>
 , <span class="ch">&#39;Col &quot;age&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;RN PGInt4 Int32</span>
 ]</code></pre></div>
<p>At last we have collected in a single type all the information that is essential to describe the group of SQL columns we are interested in, and not one bit more. We are on the right track.</p>
<p>Let’s recall once again what our least polymorphic shape for <code>User</code> looked like so that we can finally break it apart and move on:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">User</span> a b c d <span class="fu">=</span> <span class="dt">Record</span>
  <span class="ch">&#39;[ Tagged &quot;id&quot;             a</span>
   , <span class="dt">Tagged</span> <span class="st">&quot;name&quot;</span>           b
   , <span class="dt">Tagged</span> <span class="st">&quot;favoriteNumber&quot;</span> c
   , <span class="dt">Tagged</span> <span class="st">&quot;age&quot;</span>            d
   ]</code></pre></div>
<p>The first thing to notice is that <code>Record :: [*] -&gt; *</code> is a type-constructor expecting a monomorphic type-level list as an argument. That is, we can postpone worrying about <code>Record</code> until we figure out how to derive suitable monomorphic lists from our list of <code>Col</code>s. The second thing to notice, similarly, is that <code>Tagged :: Symbol -&gt; * -&gt; *</code> is another type-constructor we apply to types that we know are present in our <code>Col</code> descriptions, which means that we can generalize this a bit and say that to each <code>Col</code> we will apply a type-level function <code>f :: Col Symbol WD RN * * -&gt; *</code> leading to a type looking like a fully applied <code>Tagged :: Symbol -&gt; * -&gt; *</code>, where the second argument to said <code>Tagged</code> will vary depending on the Opaleye scenario.</p>
<p>The first thing we need to do is figure out how convert each of our <code>Col</code>s into the type expected for this column by our <code>User_HsR</code> from before. That is, <code>Tagged &quot;id&quot; Int32</code>, <code>Tagged &quot;age&quot; (Maybe Int32)</code>, etc. We already know how to do this using type-level functions, so without further ado I present to you the answer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Col_HsR</span> (<span class="ot">col ::</span> <span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Col_HsR</span> (<span class="ch">&#39;Col n w &#39;</span><span class="dt">R</span>  p h) <span class="fu">=</span> <span class="dt">Tagged</span> n h
  <span class="dt">Col_HsR</span> (<span class="ch">&#39;Col n w &#39;</span><span class="dt">RN</span> p h) <span class="fu">=</span> <span class="dt">Tagged</span> n (<span class="dt">Maybe</span> h)</code></pre></div>
<p>The type <code>Col_HsR ('Col &quot;id&quot; 'WD 'R PGInt4 Int32)</code> reduces to <code>Tagged &quot;id&quot; Int32</code> as expected, and similarly for the other columns. Hopefully by now you are not surprised that this works. The rest of the scenarios are similar and don’t introduce any new ideas:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Col_HsI</span> (<span class="ot">col ::</span> <span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Col_HsI</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">W</span>  <span class="ch">&#39;R  p h) = Tagged n h</span>
  <span class="dt">Col_HsI</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">W</span>  <span class="ch">&#39;RN p h) = Tagged n (Maybe h)</span>
  <span class="dt">Col_HsI</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">WD</span> <span class="ch">&#39;R  p h) = Tagged n WDef h</span>
  <span class="dt">Col_HsI</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN p h) = Tagged n (WDef (Maybe h))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Col_PgR</span> (<span class="ot">col ::</span> <span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Col_PgR</span> (<span class="ch">&#39;Col n w &#39;</span><span class="dt">R</span>  p h) <span class="fu">=</span> <span class="dt">Tagged</span> n (<span class="dt">Kol</span> p)
  <span class="dt">Col_PgR</span> (<span class="ch">&#39;Col n w &#39;</span><span class="dt">RN</span> p h) <span class="fu">=</span> <span class="dt">Tagged</span> n (<span class="dt">Koln</span> p)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Col_PgRN</span> (<span class="ot">col ::</span> <span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Col_PgRN</span> (<span class="ch">&#39;Col n w r p h) = Tagged n (Koln p)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Col_PgW</span> (<span class="ot">col ::</span> <span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Col_PgW</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">W</span>  <span class="ch">&#39;R  p h) = Tagged n (Kol p)</span>
  <span class="dt">Col_PgW</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">W</span>  <span class="ch">&#39;RN p h) = Tagged n (Koln p)</span>
  <span class="dt">Col_PgW</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">WD</span> <span class="ch">&#39;R  p h) = Tagged n WDef (Kol p)</span>
  <span class="dt">Col_PgW</span> (<span class="ch">&#39;Col n &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN p h) = Tagged n (WDef (Koln p))</span></code></pre></div>
<p>From looking at the right hand side of these equations it is clear that the <code>Tagged n</code> part could be abstracted away. Nevertheless, we wouldn’t gain much by doing so at this point, so we will leave it at that and move on.</p>
<p>The last piece of the puzzle is selecting one of these functions depending on the Opaleye scenario we are working on, and mapping it over the type-level list of <code>Col</code>s so as to finally get the desired monomorphic type-level list <code>Record</code> expects. Mapping a type-level function over a type-level list is perfectly doable, just like mapping term-level functions over term-level lists, so we already know that is our answer. However, even if we had a high level function <code>Map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code> for applying the given function to every element of the list, that wouldn’t be sufficient. The problem is that, currently, GHC doesn’t allow us to pass a partially applied type-level function around; it requires that all our type-level functions be fully saturated, which leaves out the possibility of ever writing <code>Map Col_PgR</code>, for example. Have we reached a dead end? Fortunately, no. There exists a technique called defunctionalization that, apparently by taking the fun out of function application, allows you to work with and pass around partially applied type-level functions. We are not particularly interested in the details of this technique today, it should suffice to say that you may already be familiar with the principles of it if you have ever used the <code>ApplyAB</code> class in the <code>HList</code> library. In our case, we will use the defunctionalization support offered by Richard Eisenberg’s <a href="https://hackage.haskell.org/package/singletons"><code>singletons</code></a> library, which among many other things, will allow us to map the type-level functions on <code>Col</code> we just wrote over a list of <code>Col</code>s. So, doing a bit of wishful thinking regarding the implementation, we will assume we got to write functions like these:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Takes a list of &#39;Col&#39;s and applies &#39;Col_HsR&#39; to each of them.</span>
<span class="kw">type</span> <span class="dt">Cols_HsR</span><span class="ot"> ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>] <span class="ot">-&gt;</span> [<span class="fu">*</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Takes a list of &#39;Col&#39;s and applies &#39;Col_HsI&#39; to each of them.</span>
<span class="kw">type</span> <span class="dt">Cols_HsI</span><span class="ot"> ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>] <span class="ot">-&gt;</span> [<span class="fu">*</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Takes a list of &#39;Col&#39;s and applies &#39;Col_PgR&#39; to each of them.</span>
<span class="kw">type</span> <span class="dt">Cols_PgR</span><span class="ot"> ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>] <span class="ot">-&gt;</span> [<span class="fu">*</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Takes a list of &#39;Col&#39;s and applies &#39;Col_PgRN&#39; to each of them.</span>
<span class="kw">type</span> <span class="dt">Cols_PgRN</span><span class="ot"> ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>] <span class="ot">-&gt;</span> [<span class="fu">*</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Takes a list of &#39;Col&#39;s and applies &#39;Col_PgW&#39; to each of them.</span>
<span class="kw">type</span> <span class="dt">Cols_PgW</span><span class="ot"> ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>] <span class="ot">-&gt;</span> [<span class="fu">*</span>]</code></pre></div>
<p>If you are interested in the details of how these are implemented you can take a look at the code in <code>opaleye-sot</code>. It can be useful to understand this technique if you are going to be spending more time in the type system.</p>
<p>With these in place, we can start worrying about where to keep all this information about our rows.</p>
<h2 id="tables">Tables</h2>
<p>So far we have talked about SQL rows but not particularly in the context of SQL tables. This was a deliberate choice meant to reinforce the idea that in most cases you can think of an SQL row as just a list of columns resulting from an SQL query, perhaps across many tables. Still, making the connection between SQL rows and SQL tables is necessary in many cases, so we will work on that.</p>
<p>We want to treat each table as a completely different entity and have the type-checker help us enforce it so that not even tables that have the same shape can be accidentally confused. But, as different as these tables might be, we want to be able to work with all of them in a uniform and lightweight manner. Accomplishing all of this will be our goal.</p>
<p>In PostgreSQL each table can be uniquely identified by its name and the name of the schema it belongs to. These are just strings, and we already know that strings can exists at the type-level in the form of <code>Symbol</code>. For our <code>user</code> table we can say that <code>&quot;user&quot; :: Symbol</code> is its name, and that <code>&quot;public&quot; :: Symbol</code> is the name of its schema. With this in mind we can restrict the type-level list of <code>Col</code>s from before so that it is tied to this particular <code>user</code> table and not to any other table that might share its shape. As before, we accomplish this by simply tagging our list with additional information:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Tagged</span> <span class="ch">&#39;(&quot;public&quot;, &quot;user&quot;)</span>
  <span class="ch">&#39;[ &#39;</span><span class="dt">Col</span> <span class="st">&quot;id&quot;</span> <span class="ch">&#39;WD &#39;</span><span class="dt">R</span> <span class="dt">PGInt4</span> <span class="dt">Int32</span>
   , <span class="ch">&#39;Col &quot;name&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;R PGText Text</span>
   , <span class="ch">&#39;Col &quot;favoriteNumber&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN PGInt4 Int32</span>
   , <span class="ch">&#39;Col &quot;age&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;RN PGInt4 Int32</span>
   ]</code></pre></div>
<p>But still, where do we define this? Where do we actually write this type in our code? Of course we could assign a type synonym to this type expression and move on, but that would mean introducing a new type synonym for every table that we wanted to support, and we wouldn’t be able to enforce some constraints we would like to enforce on these types at their definition site. We will instead rely on <em>open type families</em>, or more precisely, <em>associated open type families</em>. These will allow us to achieve all of our goals.</p>
<p>The type-level functions we have been using until know are officially known as <em>closed type families</em>, and what is so special about them is that, akin to normal term-level functions, all of their patterns must be defined on the very same place within the body of its <code>where</code> clause. On the other hand, <em>open type families</em> are defined more like typeclasses and their instances: we declare the type family just once in a single place and then give instances for that type family possibly across different modules. This <em>open world assumption</em> makes open type families fundamentally necessary if we don’t know at compile time all of the types on which our type-level function should work, like in our case. The differences in syntax between open and closed type families are minimal. For example, let’s convert our <code>Bar</code> closed type family from before into an open type family.</p>
<p>From a closed type family:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Bar</span> (<span class="ot">x ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Bar</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Bool</span>
  <span class="dt">Bar</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Double</span></code></pre></div>
<p>To a single open type family declaration:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Bar</span> (<span class="ot">x ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p>And to zero or more open type family instances, possibly defined across different modules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Bar</span> <span class="dt">Int</span>  <span class="fu">=</span> <span class="dt">Bool</span>
<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Bar</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Double</span></code></pre></div>
<p>Having this new knowledge, we can now create a new type family named <code>Cols</code> that when applied to the names of a schema and a table, it gives us our tagged list of <code>Col</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Cols</span> (<span class="ot">schema ::</span> <span class="dt">Symbol</span>) (<span class="ot">table ::</span> <span class="dt">Symbol</span>)
<span class="ot">  ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>]</code></pre></div>
<p>Assuming <code>Cols</code> is being provided by some hypotetical library, users of this type family simply have to provide new instances for it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Cols</span> <span class="st">&quot;public&quot;</span> <span class="st">&quot;user&quot;</span> <span class="fu">=</span>
  <span class="ch">&#39;[ &#39;</span><span class="dt">Col</span> <span class="st">&quot;id&quot;</span> <span class="ch">&#39;WD &#39;</span><span class="dt">R</span> <span class="dt">PGInt4</span> <span class="dt">Int32</span>
   , <span class="ch">&#39;Col &quot;name&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;R PGText Text</span>
   , <span class="ch">&#39;Col &quot;favoriteNumber&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN PGInt4 Int32</span>
   , <span class="ch">&#39;Col &quot;age&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;RN PGInt4 Int32</span>
   ]</code></pre></div>
<p>And if there also existed a type-level function like the <code>TaggedCols</code> below, <code>TaggedCols &quot;public&quot; &quot;user&quot;</code> would equal our tagged list of <code>Col</code>s from before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TaggedCols</span> (<span class="ot">schema ::</span> <span class="dt">Symbol</span>) (<span class="ot">table ::</span> <span class="dt">Symbol</span>)
  <span class="fu">=</span> <span class="dt">Tagged</span> <span class="ch">&#39;(schema, table) (Cols schema table)</span></code></pre></div>
<p>However, this is still unsatisfactory. The problem is that maybe in our codebase we happen to need to interact with two or more different databases at the same time, where two or more of them might have tables named <code>&quot;user&quot;</code> in a schema named <code>&quot;public&quot;</code> with shapes different from the one we just laid out. However, our current approach with <code>Cols</code> requires that there exists only one combination of schema name and table name. In order to fix this, <code>Cols</code> needs to take a third type parameter that uniquely identifies the database where the table exists. We are not interested in what this type is, we are only interested in the meaning we decide to give to its role: This type parameter will be used as a unique identifier for a database, and as long as it is equal to another type used in a similar way we will say that we are talking about a same database, otherwise we will say that we are talking about different ones. It is up to the user to decide which type to provide, we the library authors are not interested in the type per se but in its role. So, our definition of <code>Cols</code> will look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Cols</span> (<span class="ot">database ::</span> k) (<span class="ot">schema ::</span> <span class="dt">Symbol</span>) (<span class="ot">table ::</span> <span class="dt">Symbol</span>)
<span class="ot">  ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>]</code></pre></div>
<p>And then an instance for one database could look like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | This is only ever used at the type level to uniquely identify a specific</span>
<span class="co">-- database. All the tables belonging to this database should use this same</span>
<span class="co">-- identifier.</span>
<span class="kw">data</span> <span class="dt">Db1</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Cols</span> <span class="dt">Db1</span> <span class="st">&quot;public&quot;</span> <span class="st">&quot;user&quot;</span> <span class="fu">=</span>
  <span class="ch">&#39;[ &#39;</span><span class="dt">Col</span> <span class="st">&quot;id&quot;</span> <span class="ch">&#39;WD &#39;</span><span class="dt">R</span> <span class="dt">PGInt4</span> <span class="dt">Int32</span>
   , <span class="ch">&#39;Col &quot;name&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;R PGText Text</span>
   , <span class="ch">&#39;Col &quot;favoriteNumber&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN PGInt4 Int32</span>
   , <span class="ch">&#39;Col &quot;age&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;RN PGInt4 Int32</span>
   ]</code></pre></div>
<p>And for another database something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Db2</span>

<span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Cols</span> <span class="dt">Db2</span> <span class="st">&quot;public&quot;</span> <span class="st">&quot;user&quot;</span> <span class="fu">=</span> <span class="co">-- ... not important</span></code></pre></div>
<p>One last detail: Since we now have incoming information about the database where the table exists, we should keep it instead of just throwing it away as we do in <code>Cols</code>. The reason for this is that this new information might come handy later, for example, to prevent any attempts to join tables across different databases. Indeed, <code>opaleye-sot</code> does just that. So let’s update <code>TaggedCols</code> to take this into account:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TaggedCols</span> (<span class="ot">database ::</span> k) (<span class="ot">schema ::</span> <span class="dt">Symbol</span>) (<span class="ot">table ::</span> <span class="dt">Symbol</span>)
  <span class="fu">=</span> <span class="dt">Tagged</span> <span class="ch">&#39;(database, schema, table) (Cols database schema table)</span></code></pre></div>
<p>This is a fine representation, but it is not entirely satisfying to us because we can’t add any constraints to the types that show up in it, so we will try something else. There are two reasons why we want to add constraints: First, because we want these constraint to give us early compile time errors if we get something wrong when enumerating our columns (for example, when mistaking the purpose of the last two <code>* *</code> arguments to <code>Col</code>), and second, because working with <code>Record</code> and <code>HList</code> will require that our list of <code>Col</code>s satisfies various boring constraints, and we would rather satisfy those constraints right away when defining our list instead of doing it later on each use site. Our solution, which we briefly talked about before, is <em>associated</em> open type families.</p>
<p>The difference between associated open type families and normal open type families is that associated type families are declared inside typeclasses, and instances for said type family are given within the instances for the typeclass itself. This enables us, among other things, to mention the associated type family in the class or instance context where we can further constraint them. Let’s take for example <code>Bar</code>, our open type family from before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Bar</span> (<span class="ot">x ::</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span></code></pre></div>
<p>If we wanted to convert <code>Bar</code> to an associated open type family within some class <code>Qux</code>, we would do it like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Qux</span> (<span class="ot">x ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Bar</span><span class="ot"> x ::</span> <span class="fu">*</span></code></pre></div>
<p>And instances for this typeclass and associated type family would be specified in the following way, possibly in different modules:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Qux</span> <span class="dt">Int</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Bar</span> <span class="dt">Int</span> <span class="fu">=</span> <span class="dt">Bool</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Qux</span> <span class="dt">Char</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Bar</span> <span class="dt">Char</span> <span class="fu">=</span> <span class="dt">Double</span></code></pre></div>
<p>This new <code>Bar</code> still has the kind <code>* -&gt; *</code>, and it is defined for every <code>x</code> that is an instance of <code>Qux</code>. And as we wanted, now, we can further constraint <code>Bar x</code> so that it satisfies some particular constraints. For example, we could enforce that <code>Bar x</code> be an instance of <code>Num</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Num</span> (<span class="dt">Bar</span> x) <span class="ot">=&gt;</span> <span class="dt">Qux</span> (<span class="ot">x ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Bar</span><span class="ot"> x ::</span> <span class="fu">*</span></code></pre></div>
<p>With this new definition of <code>Qux</code>, the previously given instance for <code>Qux Int</code> would fail to compile because <code>Bar Int</code> is <code>Bool</code>, which is not an instance of <code>Num</code>, effectively giving us early compile time errors at the definition site for things that would probably have been constrained on their use site anyway, leading to compile errors there later.</p>
<p>One last minor remark: Just like when using a method <code>f</code> of a class <code>X</code> on a term <code>a :: t</code> requires that there is an instance of <code>X</code> in scope that defines that method <code>f</code> in a way that it can accept <code>a :: t</code> as its argument, using a associated type family such as <code>Bar x</code> in our example will require that there exists an instance of <code>Qux x</code> in scope, meaning that this constraint will be propagated upstream until it is satisfied.</p>
<p>Let’s now convert our <code>Cols</code> to an associated open type family within a type class that we will call <code>Tisch</code>, which is the German word for “table”—a good name because it doesn’t clash with Opaleye’s <code>Table</code>, a type we will use later on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ITisch</span> d s t
   <span class="ot">=&gt;</span> <span class="dt">Tisch</span> (<span class="ot">database ::</span> k) (<span class="ot">schemaName ::</span> <span class="dt">Symbol</span>) (<span class="ot">tableName ::</span> <span class="dt">Symbol</span>)
 <span class="kw">where</span>
   <span class="kw">type</span> <span class="dt">Cols</span> database schemaName tableName
<span class="ot">     ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>]</code></pre></div>
<p>We will not pay attention at all to the internals of the <code>ITisch</code> superclass; as we suggested before, it just constraints <code>Cols</code> as we did in our <code>Qux</code> and <code>Bar</code> example, and it ensures <code>Cols</code> satisfies many constraints that will be required by <code>HList</code> and <code>Record</code>. The implementation of <code>ITisch</code> however, doesn’t teach us anything fundamentally new, so let’s ignore it. Also, the <code>TaggedCols</code> from before would continue to work just fine because <code>Cols</code> still takes the same three type arguments.</p>
<p><code>Tisch</code> as defined above is fine, but hopefully you can see that passing those three arguments everywhere will get cumbersome, even more so if we keep in mind that at times we will need to pass these values as phantom types in a <code>Proxy</code> or similar type. For this seemingly cosmetic reason we will change our <code>Tisch</code> so that it takes a single type parameter, and from it derive <code>database</code>, <code>schemaName</code> and <code>tableName</code> just like we did with <code>Cols</code>. Beyond the looks, however, this change will impact substantially on the removal of much noise that would otherwise exist in our query language—which we haven’t talked about yet.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ITisch</span> t <span class="ot">=&gt;</span> <span class="dt">Tisch</span> (<span class="ot">t ::</span> k) <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Database</span><span class="ot"> t ::</span> <span class="fu">*</span>
  <span class="kw">type</span> <span class="dt">SchemaName</span><span class="ot"> t ::</span> <span class="dt">Symbol</span>
  <span class="kw">type</span> <span class="dt">SchemaName</span> <span class="fu">=</span> <span class="st">&quot;public&quot;</span>
  <span class="kw">type</span> <span class="dt">TableName</span><span class="ot"> t ::</span> <span class="dt">Symbol</span>
  <span class="kw">type</span> <span class="dt">Cols</span><span class="ot"> t ::</span> [<span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>]</code></pre></div>
<p>Look at that, we were even able to give a default value to <code>SchemaName t</code> this time. This value can of course be overridden, but <code>&quot;public&quot;</code>, just like in PostgreSQL, serves as a good default for the schema name. Now users of <code>Tisch</code> can define their tables like this—assuming the table exists in the database we called <code>Db1</code> before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Unique type-level identifier for the &#39;&quot;public&quot;.&quot;user&quot;&#39; PosgreSQL table.</span>
<span class="kw">data</span> <span class="dt">User</span>

<span class="kw">instance</span> <span class="dt">Tisch</span> <span class="dt">User</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">Database</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">Db1</span>
  <span class="kw">type</span> <span class="dt">TableName</span> <span class="dt">User</span> <span class="fu">=</span> <span class="st">&quot;user&quot;</span>
  <span class="kw">type</span> <span class="dt">Cols</span> <span class="dt">User</span> <span class="fu">=</span>
    <span class="ch">&#39;[ &#39;</span><span class="dt">Col</span> <span class="st">&quot;id&quot;</span> <span class="ch">&#39;WD &#39;</span><span class="dt">R</span> <span class="dt">PGInt4</span> <span class="dt">Int32</span>
     , <span class="ch">&#39;Col &quot;name&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;R PGText Text</span>
     , <span class="ch">&#39;Col &quot;favoriteNumber&quot; &#39;</span><span class="dt">WD</span> <span class="ch">&#39;RN PGInt4 Int32</span>
     , <span class="ch">&#39;Col &quot;age&quot; &#39;</span><span class="dt">W</span> <span class="ch">&#39;RN PGInt4 Int32</span>
     ]</code></pre></div>
<p>The <code>Tisch</code> described here is exactly the same <code>Tisch</code> that you will find today in <code>opaleye-sot</code>.</p>
<p>All that is left is to forget about our previous <code>TaggedCols</code>, as now we have a better way of representing a table. The thing to keep in mind is that as long as we have a type <code>t</code> for which there exists an instance of <code>Tisch</code>, we can always derive from it any of <code>Database</code>, <code>SchemaName</code>, <code>TableName</code> and <code>Cols</code>, which effectively allows us to express things like <code>Tagged t (Cols t)</code> if ever needed.</p>
<h2 id="the-elephant-in-the-room">The elephant in the room</h2>
<p>An minor detail to notice, or perhaps to ignore, is that in our implementation of <code>Tisch</code> we have fixed the kind of <code>Database t</code> to <code>*</code> instead of keeping it polykinded as before. This will ease the implementation on some features related to preventing the accidental comparison of columns across different databases. But, how do we know that?</p>
<p>At this point I think we should discuss <em>the elephant in the room</em>: “How do we come up with these judgments? How do we <em>foresee</em> which of <code>*</code> or <code>k</code> will be better? How will we ever know these things for ourselves? Who are you to tell me what to write?”. And essentially, it boils down to this: Working with the type system is a very interactive and enriching activity, we learn from it, and we constantly go back to improve things, some of which we will understand and remember the next time we find ourselves solving a similar problem. The type checker is an excellent teacher and companion; we try one approach and fail, we try another approach and fail again but this time understanding why, then we succeed but later realize that maybe if we had done something a bit differently we could have covered a larger space and solved more problems, so we go back and fail again until eventually we don’t, and then we have learned something. Throughout this process we gain some understanding about which things are worth doing and which aren’t, and from there we make informed choices.</p>
<p>Up until now we have walked through this reasoning process together, but maybe this article is becoming to long and we should speed up things a bit by saving us all this back and forth with the type checker—an experience best lived personally. So when I say that the kind of <code>Database t</code> will be <code>*</code> because that will simplify some things later, or when I tell you that the <code>ITisch</code> constraint on <code>Tisch</code> is there to keep us from harm and reduce some noise related to the usage of <code>HList</code> and <code>Record</code>, what I am really saying is that for reasons that should become apparent later, these choices serve our ultimate purpose well. The type-checker told me so, as it would have told you had you two been talking.</p>
<p>Regarding these interactive sessions with the type-checker, I am sure most have their own story. For me it was years ago when I spent many hours failing to write a <code>Functor</code> instance for something like <code>(a, b)</code> where <code>fmap</code> applied the given function to both <code>a</code> and <code>b</code>: It took me a lot of time to understand that it wasn’t possible, but eventually I did, and never again I had trouble reasoning about parametric polymorphism in typeclasses and related concepts. <em>Peer-programming</em> with the type system, if you will, is a beautiful and enriching exercise no matter how silly the things we are trying to understand might seem at first. It is worth trying.</p>
<h2 id="every-type-we-will-ever-need">Every type we will ever need</h2>
<p>From a type <code>t</code> that is an instance of <code>Tisch</code> we can derive every type we will ever need for working with the Opaleye scenarios we want to support. This shouldn’t be a surprise to us, after all we have already achieved this once before with our definitions of <code>Cols_HsR</code>, <code>Cols_HsI</code>, etc. We already know that we can say <code>Cols_HsR t</code> and move on. Nevertheless, similarly to how we did with <code>TaggedCols</code> before, we would like to tag the resulting <code>Record</code> with some identifier for our table so as to keep us from accidentally attempting to, say, interpret the result of one table as the Haskell representation intended for a different one. This is no secret to us anymore: We know why telling apart apples from oranges is useful; it teaches the type system to tell right from wrong, and we value that. What we want is a type-level function like the following one, which takes as argument a <code>t</code> that is an instance of <code>Tisch</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">HsR</span> t <span class="fu">=</span> <span class="dt">Tagged</span> t (<span class="dt">Cols_HsR</span> (<span class="dt">Cols</span> t))</code></pre></div>
<p>And similarly for the <code>HsI</code>, <code>PgR</code>, <code>PgRN</code> and <code>PgW</code> scenarios. Of course, if we start putting <code>Tagged</code> values in datatypes like this one, expected to play well with Opaleye, we have to ensure <code>ProductProfunctor</code> instances can exist for them. But they can, and they are exported by <code>opaleye-sot</code>, so let’s not worry about it.</p>
<p>Fundamentally, there is not much more to this, but from a practical point of view there is one last thing to do: Just like we created <code>WDef</code>, <code>WD</code> and <code>RN</code> to help us reason about meaning, we will create a new type isomorphic to <code>Proxy</code> that we will use to exclusively tag types that are one of our <code>Tisch</code> instances.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- “T” stands for table, of course.</span>
<span class="kw">data</span> <span class="dt">Tisch</span> t <span class="ot">=&gt;</span> <span class="dt">T</span> (<span class="ot">t ::</span> k) <span class="fu">=</span> <span class="dt">T</span></code></pre></div>
<p>This will prevent us from accidentally confusing, say, a <code>Tagged</code> list of columns for a table from a <code>Tagged</code> single column, because we know that we will only ever use <code>T</code> to tag things that concern the entire table. As a bouns, this will the improve the clarity and readability of queries and compiler errors when using <code>T</code> within Opaleye’s query language. Hopefully you will agree that writing <code>T::T User</code>—which we will frequently need to write in our query language—can lead to code that is more readable than if we used the usual <code>Proxy :: Proxy User</code>, and that compilation errors talking about <code>T</code> will guide us in the right direction. So, we will change the <code>HsR</code> function we just introduced, as well as its siblings, to use <code>T</code>. Later on, when paying attention to the query language, we will see more sophisticated uses for <code>T</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">HsR</span> t <span class="fu">=</span> <span class="dt">Tagged</span> (<span class="dt">T</span> t) (<span class="dt">Cols_HsR</span> (<span class="dt">Cols</span> t))</code></pre></div>
<p>Actually, this is a very good idea; let’s introduce a similar type for tagging columns belonging to a particular table, reproducing the gains from <code>T</code> in yet another scenario:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- “TC” stands for table column, of course. &#39;c&#39; carries the name of the column.</span>
<span class="kw">data</span> <span class="dt">Tisch</span> t <span class="ot">=&gt;</span> <span class="dt">TC</span> (<span class="ot">t ::</span> k) (<span class="ot">c ::</span> <span class="dt">Symbol</span>) <span class="fu">=</span> <span class="dt">TC</span></code></pre></div>
<p>We will see sophisticated use cases for <code>TC</code> later when we look at the query language. For now we will just change our previous implementation of <code>Col_HsR</code> and its siblings to tag each column using <code>TC</code>, instead of just the name of the column:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Col_HsR</span> (<span class="ot">t ::</span> k) (<span class="ot">col ::</span> <span class="dt">Col</span> <span class="dt">Symbol</span> <span class="dt">WD</span> <span class="dt">RN</span> <span class="fu">*</span> <span class="fu">*</span>)<span class="ot"> ::</span> <span class="fu">*</span> <span class="kw">where</span>
  <span class="dt">Col_HsR</span> t (<span class="ch">&#39;Col n w &#39;</span><span class="dt">R</span>  p h) <span class="fu">=</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t n) h
  <span class="dt">Col_HsR</span> t (<span class="ch">&#39;Col n w &#39;</span><span class="dt">RN</span> p h) <span class="fu">=</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t n) (<span class="dt">Maybe</span> h)</code></pre></div>
<p>And finally, after a long journey of understanding, <code>HsR</code> and its siblings have the expected behavior. This is, for example, the type <code>PgW User</code> reduces to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Tagged</span>
  (<span class="dt">T</span> <span class="dt">User</span>)
  (<span class="dt">Record</span>
    <span class="ch">&#39;[ Tagged (TC User &quot;id&quot;)             (WDef (Kol PGInt4))</span>
     , <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;name&quot;</span>)           (<span class="dt">Kol</span> <span class="dt">PGText</span>)
     , <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;favoriteNumber&quot;</span>) (<span class="dt">WDef</span> (<span class="dt">Koln</span> <span class="dt">PGInt4</span>))
     , <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;age&quot;</span>)            (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
     ])</code></pre></div>
<p>To appreciate the reach of what we have accomplished let’s contemplate the fact that <code>Table (PgW User) (PgR User)</code> is now a perfectly acceptable type for the argument to Opaleye’s <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Table.html#v:queryTable"><code>queryTable</code></a> or any of the <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Manipulation.html">manipulation functions</a> in Opaleye, that <code>Query (PgR User)</code> is an acceptable type for the return type of <code>queryTable</code>, that <code>PgRN User</code> can be one of the types resulting from a <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Join.html#v:leftJoin"><code>leftJoin</code></a> that a function <code>PgR User -&gt; PgW User</code> can be passed as a callback argument to <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Manipulation.html#v:runUpdate"><code>runUpdate</code></a>, and that a list of <code>HsR User</code> can be obtained from <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-RunQuery.html#v:runQuery"><code>runQuery</code></a>. All of this without specifying the details for the <code>user</code> table more than once, and without relying in <code>TemplateHaskell</code> for it. We have achieved a lot, we distanced ourselves from <em>the wrong SQL</em> a bit more, and we understand everything there is to understand about how we did it.</p>
<p>We have completed our understanding of how to represent SQL tables in the type system. If you would like to make a pause before continuing, this would be a good time. Next we will learn how to use the tables we have defined here.</p>
<h2 id="tisch-befriends-opaleye">Tisch befriends Opaleye</h2>
<p>The simplest useful thing we can do with a SQL table is to query it. Opaleye exports an function named <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Table.html#v:queryTable"><code>queryTable</code></a> that does just that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">queryTable ::</span> <span class="dt">Default</span> <span class="dt">ColumnMaker</span> r r <span class="ot">=&gt;</span> <span class="dt">Table</span> w r <span class="ot">-&gt;</span> <span class="dt">QueryArr</span> () r</code></pre></div>
<p>The <code>Default ColumnMaker</code> bit is not important right now, you can ignore it. First, as we usually do when reading function types, we will pay attention to the return type. <code>QueryArr () r</code> is the type of an Opaleye query that, through an <code>Arrow</code> interface, takes an argument of type <code>()</code> and returns a value of type <code>r</code>. Notice that just like we can’t tell from the type <code>Maybe Int</code> whether it contains <code>Just 5</code> or <code>Nothing</code>, we can’t tell from the type what this <code>QueryArr () r</code> does. However, if we were to look inside it we would find that it generates a query analogous to <code>SELECT a.x, a.y FROM s.t a</code>, and for now you will have to just trust me on this. The result of this query, that is, the <code>r</code> in <code>QueryArr () r</code>, will be a Haskell representation of the values in the selected PostgreSQL columns. The <code>()</code>, as you can probably imagine, is superfluous, yet it needs to be passed around to satisfy the needs of the <code>Arrow</code> interface. Thus, we conclude that any knowledge about <code>s</code>, <code>t</code>, <code>x</code> and <code>y</code> must come from the passed in <code>Table w r</code>.</p>
<p>We know that a <code>Table w r</code> must specify at least its name and the name of its schema, none of which show up in the type, as well as the Haskell representation for PostgreSQL values in table columns showing up as <code>r</code> in the type. We already know this much. Additionally, we can learn from Opaleye’s documentation that <code>w</code> indicates the Haskell representation of PostgreSQL values when these are being written to the table columns. From this we can hypothesize that <code>Table (PgW User) (PgR User)</code>, for example, should be an acceptable type for the description of our <code>user</code> table. And indeed it is. But how do we construct a <code>Table (PgW User) (PgR User)</code>? The <code>Opaleye</code> documentation points us to the <code>TableWithSchema</code> constructor for <code>Table</code> and explains how to build one by hand. But of course, we don’t want to do this by hand because we know that manual processes are error prone and their results are hard to maintain. Instead, knowing that within <code>Tisch</code> we already have, at the type-level, all the information that the <code>TableWithSchema</code> constructor wants, we will write a function that given a <code>t</code> that is an instance of <code>Tisch</code>, it returns a <code>Table (PgW t) (PgR t)</code>. In other words, we want to implement this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">table ::</span> <span class="dt">T</span> t <span class="ot">-&gt;</span> <span class="dt">Table</span> (<span class="dt">PgW</span> t) (<span class="dt">PgR</span> t)</code></pre></div>
<p>We could have used <code>Proxy</code> instead of <code>T</code> to pass around the type <code>t</code>, but as we said before, in <code>opaleye-sot</code> we use <code>T</code> throughout the API whenever we want to tag something that has a <code>Tisch</code> instance, as this leads to more readable code in the query language and to more helpful error messages.</p>
<p>Even if quite illuminating, I won’t go into the details of how <code>table</code> is implemented because it is not fundamentally important and it would take a long time to explain; you are invited read the source code for it in <code>opaleye-sot</code> if you are curious. It should suffice to say that given a <code>t</code>, we convert <code>SchemaName t</code> and <code>TableName t</code> to <code>String</code>s using <code>symbolVal</code>, then seemingly out of thin air we make a term-level value of type <code>TableProperties (PgW t) (PgR t)</code>, and finally we just give those three arguments to <code>TableWithSchema</code>. I promise this is not a magical process, this is just profiting at the term-level from information that is already present at the type-level. You can always go from types to terms in Haskell—what’s hard is going in the other direction, but we are not trying to accomplish that today.</p>
<p>With <code>table</code> implemented, we finally have a way to derive a <code>Table (PgW t) (PgR t)</code> for any <code>Tisch t</code>. For example, we can write:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">queryUsersTable ::</span> <span class="dt">QueryArr</span> () (<span class="dt">PgR</span> <span class="dt">User</span>)
queryUsersTable <span class="fu">=</span> queryTable (table (<span class="dt">T</span><span class="ot">::</span><span class="dt">T</span> <span class="dt">User</span>))</code></pre></div>
<p>Or, assuming we had another table described by <code>Tisch Drawing</code> that for some users provided details about their drawings, we could even use <code>table</code> to do a left join between them, using the <code>leftJoin</code> exported from <code>opaleye-sot</code>, which is basically <code>opaleye</code>’s <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Join.html#v:leftJoin"><code>leftJoin</code></a> made compatible with <code>Kol</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">queryUsersAndDrawings ::</span> <span class="dt">QueryArr</span> () (<span class="dt">PgR</span> <span class="dt">User</span>, <span class="dt">PgRN</span> <span class="dt">Drawing</span>)
queryUsersAndDrawings <span class="fu">=</span>
  leftJoin (queryTable (table (<span class="dt">T</span><span class="ot">::</span><span class="dt">T</span> <span class="dt">User</span>)))
           (queryTable (table (<span class="dt">T</span><span class="ot">::</span><span class="dt">T</span> <span class="dt">Drawing</span>)))
           (\(user, drawing) <span class="ot">-&gt;</span>
               <span class="co">{- the implementation here is not important -}</span>)</code></pre></div>
<p>In general, we can write <code>table (T::T t)</code> wherever a <code>Table w r</code> is expected. And actually, since a lot of times <code>t</code> can be inferred, such as in the <code>queryUsersTable</code> example above, <code>opaleye-sot</code> exports a variant of <code>table</code> that doesn’t take <code>t</code> explicitly but instead infers it from the context. This doesn’t always work, of course, but when it does it reduces some of the noise in Opaleye queries.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">table&#39; ::</span> <span class="dt">Tisch</span> t <span class="ot">=&gt;</span> <span class="dt">Table</span> (<span class="dt">PgW</span> t) (<span class="dt">PgR</span> t)</code></pre></div>
<p>In <code>opaleye-sot</code> you will often have variants of the same function, like <code>table</code> and <code>table'</code> here, where the one whose name ends with <code>'</code> is the one whose type is expected to be inferred from its context at the use site. We can now rewrite <code>queryUsersTable</code> to use <code>table'</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">queryUsersTable ::</span> <span class="dt">QueryArr</span> () (<span class="dt">PgR</span> <span class="dt">User</span>)
queryUsersTable <span class="fu">=</span> queryTable table&#39;</code></pre></div>
<p>In fact, this is so common that <code>opaleye-sot</code> exports these two functions for us:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">queryTisch&#39; ::</span> <span class="dt">Tisch</span> t <span class="ot">=&gt;</span> <span class="dt">Query</span> (<span class="dt">PgR</span> t)
queryTisch&#39; <span class="fu">=</span> queryTable table&#39;

<span class="ot">queryTisch ::</span> <span class="dt">Tisch</span> t <span class="ot">=&gt;</span> <span class="dt">T</span> t <span class="ot">-&gt;</span> <span class="dt">Query</span> (<span class="dt">PgR</span> t)
queryTisch _ <span class="fu">=</span> queryTisch&#39;</code></pre></div>
<p><code>Query</code>, which you haven’t seen before, is simply a synonym for <code>QueryArr ()</code>. That is, <code>Query (PgR t)</code> means <code>QueryArr () (PgR t)</code>. This comes handy since most of the times the first argument to <code>QueryArr</code> will be <code>()</code> anyway.</p>
<p>Now we can rewrite <code>queryUsersTable</code> once again:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">queryUsersTable ::</span> <span class="dt">Query</span> (<span class="dt">PgR</span> <span class="dt">User</span>)
queryUsersTable <span class="fu">=</span> queryTisch&#39;</code></pre></div>
<p>But then, why bother? We have simplified the implementation of <code>queryUsersTable</code> so much that maybe it is not worth giving its definition a top-level name anymore; we could just inline <code>queryTisch'</code> or <code>queryTisch (T::T User)</code> wherever needed. One of the goals of <code>opaleye-sot</code> is exactly this: Making the things that are used in the query language feel so lightweight that we can’t justify using them anywhere but inline within a query, effectively reducing the maintenance costs over time, as well as the reading and writing overhead.</p>
<h2 id="interpreting-results">Interpreting results</h2>
<p>Let’s now run <code>queryTisch (T::T User)</code> and interpret the results as a Haskell datatype. Opaleye exports a function named <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-RunQuery.html#v:runQuery"><code>runQuery</code></a> which we will use in this example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runQuery ::</span> <span class="dt">Default</span> <span class="dt">QueryRunner</span> r h <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> r <span class="ot">-&gt;</span> <span class="dt">IO</span> [h]</code></pre></div>
<p>We will not worry too much about the <code>Default QueryRunner r h</code> constraint, it only says that it should be possible to convert from the representation as type <code>r</code> of a PostgreSQL query result to a term of type <code>h</code> representing the values in the columns of that result in the actual Haskell runtime. We know from before that when querying just a single table such as <code>User</code>, <code>r</code> will be <code>PgR User</code> and <code>h</code> will be <code>HsR User</code> which we designed specifically for this purpose:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getUsers ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">HsR</span> <span class="dt">User</span>]
getUsers conn <span class="fu">=</span> runQuery conn (queryTisch (<span class="dt">T</span><span class="ot">::</span><span class="dt">T</span> <span class="dt">User</span>))</code></pre></div>
<p>In the case of results where all of the columns are possibly <code>NULL</code>, like when there is a missing right hand side on a <code>LEFT JOIN</code>, you may use <code>Maybe (HsR t)</code> as the result type. For example, running <code>queryUsersAndDrawings</code> from before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getUsersAndDrawings ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">HsR</span> <span class="dt">User</span>, <span class="dt">Maybe</span> (<span class="dt">HsR</span> <span class="dt">Drawing</span>)]
getUsersAndDrawings conn <span class="fu">=</span> runQuery conn queryUsersAndDrawings</code></pre></div>
<p>At some point we may want to convert these <code>HsR User</code> and <code>HsR Drawing</code> to other internal representations of our own. This is not necessary though, if <code>HsR User</code> suffices for us we can definitely work with that, and then we would have the entire <code>Record</code> API at our disposal out of the box. But maybe we need to interface with other piece of our codebase or a third party library that expects a different representation for a user or a drawing, and for those cases you will want to abandon the <code>HsR User</code> representation. A simple homemade function <code>HsR User -&gt; Maybe MyUser</code> would work just fine, but for your convenience <code>opaleye-sot</code> exports a typeclass <code>Tisch t =&gt; UnHsR t a</code> with a single method <code>unHsR' :: HsR t -&gt; Either SomeException a</code>. This is mostly so that we can treat conversions from any <code>HsR t</code> uniformly and that we don’t have to think of names for these conversions functions, which is very very hard. The monomorphic <code>Either SomeException</code> wrapper around <code>a</code> makes the <code>Applicative</code> and <code>Monad</code>ic composition of <code>unHsR'</code> results very practical, a desirable property when trying to combine results from different queries; and of course, the <code>SomeException</code> is there so that you can be very precise about why converting from <code>HsR User</code> to <code>MyUser</code> failed, for example.</p>
<p>As a general recommendation: Remember that as our application evolves <code>HsR User</code> will probably change, so we should build resilient code here. The best way to do this, of course, is by always preferring to use the most precise types available, but sometimes that won’t be practical; for example, you wouldn’t create an <code>PersonAgeInYears</code> type that contains an integer number between 0 and whatever the optimal life expectancy is, instead you would just use an unsigned integer. If we had favorite colors, for example, and we knew that the only acceptable favorite colors within <code>MyUser</code> would be red, black or purple, then we should check this explicitly when converting from <code>HsR User</code> to <code>MyUser</code> and fail with a precise exception if it is not the case. We may for example fail with a <code>MyUser_BadFavoriteColour</code> exception, which will be very easy to recognize if it ever happens in the future. We have a powerful language at our disposal, let’s use it wisely.</p>
<h2 id="inserting-rows">Inserting rows</h2>
<p>We will now go in the other direction: From Haskell into the PostgreSQL database. We know we have thought about this scenario before when we implemented <code>HsI</code> and <code>PgW</code>, so we should be covered. Let’s just worry about how to actually perform an insert using the <a href="https://hackage.haskell.org/package/opaleye-0.4.2.0/docs/Opaleye-Manipulation.html#v:runInsert"><code>runInsert</code></a> function from <code>opaleye</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runInsert ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Table</span> w r <span class="ot">-&gt;</span> w <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></code></pre></div>
<p>There’s nothing fundamentally new for us here: We already know what <code>Table w r</code> means and we know that <code>Table (PgW t) (PgR t)</code> is a suitable candidate for it. The returned <code>Int64</code> is of no particular concern to us at this point, it just mentions the number of rows that were actually inserted to the database. We know how to build a <code>Table (PgW t) (PgR t)</code> by means of <code>table</code>, but how do we build the <code>PgW t</code> we need to pass as a second argument? Well, <code>PgW t</code> is just a <code>Record</code> with nothing more than <code>Tagged</code>s, <code>Kol</code>s, <code>Koln</code>s and <code>WDef</code>s in it, so in principle we could build it by hand. In practice, however, it is easier to build an <code>HsI t</code> first and then have that automatically converted to a <code>PgW t</code>.</p>
<p>An <code>HsI t</code>, as we already know, will be a <code>Record</code> containing plain old Haskell values like <code>Maybe</code>, <code>Int</code>, etc. That is, there is nothing secret about it and we can use any of the tools exported by the <code>HList</code> library to build one. As a convenience, <code>opaleye-sot</code> exports a function named <code>mkHsI</code> for constructing an <code>HsI t</code> in a resilient and practical way. Similarly to the <a href="https://hackage.haskell.org/package/HList-0.4.1.0/docs/Data-HList-HList.html#g:8"><code>hEndR</code></a> function for building <code>Record</code>s, <code>mkHsI</code> is intended to be used together with <a href="https://hackage.haskell.org/package/HList-0.4.1.0/docs/Data-HList-HList.html#v:hBuild"><code>hBuild</code></a>. For example, using <code>mkHsI</code> you could write the following function that constructs an <code>HsI User</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">toHsI_User
<span class="ot">  ::</span> <span class="dt">Text</span>                <span class="co">-- ^ Name.</span>
  <span class="ot">-&gt;</span> <span class="dt">WDef</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)  <span class="co">-- ^ Favorite number.</span>
  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>         <span class="co">-- ^ Age.</span>
  <span class="ot">-&gt;</span> <span class="dt">HsI</span> <span class="dt">User</span>
toHsI_User name favoriteNumber age <span class="fu">=</span>
   mkHsI <span class="fu">$</span> \set_ <span class="ot">-&gt;</span> hBuild
      (set_ (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;id&quot;</span>) <span class="dt">WDef</span>)
      (set_ (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;name&quot;</span>) name)
      (set_ (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;favoriteNumber&quot;</span>) favoriteNumber)
      (set_ (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;age&quot;</span>) age)</code></pre></div>
<p><code>mkHsI</code> takes as its only argument a function <code>f</code> that will return an <code>HList</code> of all the <code>Tagged (TC t c) a</code> elements <code>HsI t</code> expects, but not necessarily in its canonical order. This function <code>f</code> is passed as its only argument yet another function, here bound to the name <code>set_</code>, that will allow us to construct one of those <code>Tagged (TC t c) a</code> values effectively associating a value <code>a</code> to a column named <code>c</code> in the table uniquely identified by <code>t</code>. Perhaps this is easier to understand if you think of <code>set_</code> just an assignment operator, here named <code>.=</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mkHsI <span class="fu">$</span> \(<span class="fu">.=</span>) <span class="ot">-&gt;</span> hBuild
   ((<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;id&quot;</span>)             <span class="fu">.=</span> <span class="dt">WDef</span>)
   ((<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;name&quot;</span>)           <span class="fu">.=</span> name)
   ((<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;favoriteNumber&quot;</span>) <span class="fu">.=</span> favoriteNumber)
   ((<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;age&quot;</span>)            <span class="fu">.=</span> age)</code></pre></div>
<p>This is no magic. What we are seeing here, for the first time, is an usage of the type-level names we gave to columns: <code>C &quot;id&quot;</code> uniquely identifies a column named <code>&quot;id&quot;</code> in some table at the type-level. We already knew that we would be using these as sort of references to our columns, so this shouldn’t come as a surprise. <code>C</code> is comparable to the <code>Proxy</code>-like types <code>T</code> and <code>TC</code> what we saw before, and it exists for similar reasons and serves related purposes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">C</span> (<span class="ot">c ::</span> <span class="dt">Symbol</span>) <span class="fu">=</span> <span class="dt">C</span></code></pre></div>
<p><code>C</code> simply carries type-level information about the name of a column. Notice that the type <code>TC t c</code> is isomorphic to <code>(T t, C c)</code>. That is, <code>C c</code> is “the other half” to <code>T t</code> which we have seen before. The <code>set_</code> function we just saw enriches a <code>C</code> with knowledge about which table we are talking about, which of course <code>mkHsI</code> already knows about. That is, it flattens a <code>T t</code> and a <code>C c</code> into a single <code>TC t c</code> which it then uses to tag a value of type <code>a</code>. For example, if we were trying to build an <code>HsI User</code> using <code>mkHsI</code>, then <code>set_</code> would have the following type and implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set_ ::</span> <span class="dt">C</span> c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> c) a
set_ _ <span class="fu">=</span> <span class="dt">Tagged</span></code></pre></div>
<p>And as expected, the whole <code>mkHsI</code> expression <em>will fail to compile</em> if the names of the columns do not match the names first defined in the <code>Tisch</code> instance for <code>User</code>. This is what we wanted from the beginning: The type-checker doing an excellent job keeping <em>the wrong SQL</em> away from us.</p>
<p>It is worth mentioning that writing <code>C::C</code> and <code>T::T</code>, instead of the more <em>whitespacey</em> and traditional <code>C :: C</code> and <code>T :: T</code> is just a personal syntactic preference of mine so as to reduce any accidental whitespace noise. You may choose to do otherwise. Maybe this aspect of things will improve once the <a href="https://phabricator.haskell.org/D1138"><code>TypeApplications</code></a> language extension lands in GHC.</p>
<p>Now that we have an <code>HsI User</code> all we need is to do is convert it to a <code>PgW User</code> that we can pass as an argument to <code>runQuery</code>, which we can do with a function called <code>toPgW'</code> exported by <code>opaleye-sot</code> for such purpose. And now, at last we can insert a row into the <code>User</code> table, here from within an example function named <code>insertUser</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">insertUser
<span class="ot">  ::</span> <span class="dt">Connection</span>          <span class="co">-- ^ PostgreSQL Connection.</span>
  <span class="ot">-&gt;</span> <span class="dt">Text</span>                <span class="co">-- ^ User name.</span>
  <span class="ot">-&gt;</span> <span class="dt">WDef</span> (<span class="dt">Maybe</span> <span class="dt">Int32</span>)  <span class="co">-- ^ User favorite number.</span>
  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int32</span>         <span class="co">-- ^ User age.</span>
  <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span>
insertUser conn name favNum age <span class="fu">=</span>
   runInsert conn table&#39;
      (toPgW&#39; (toHsI_User name favNum age))</code></pre></div>
<p>One last thing: Just like we had the <code>UnHsR</code> typeclass saving us from the need to name functions such as <code>toHsI_User</code> and allowing us to treat this kind of conversion uniformly across our codebase, there exists a similar typeclass named <code>ToHsI</code> serving a similar purpose. The <code>toPgW'</code> function is polymorphic enough that it will happily accept an <code>HsI t</code> or any <code>a</code> that can be converted to an <code>HsI t</code> through the <code>ToHsI</code> typeclass.</p>
<h2 id="querying">Querying</h2>
<p><code>opaleye-sot</code> encourages you to use exactly the same querying infrastructure as <code>opaleye</code>, that is, the <code>Arrow</code> interface for <code>QueryArr</code> or <code>Query</code>. We don’t change anything there, but we do add new features. The first feature we added was <code>queryTisch</code>, which removed a lot of noise from our queries by allowing us to specify few or no types. The second feature is that, by having a uniform representations for all our tables, <code>opaleye-sot</code> can provide tools for working with them generically: You will learn to use these tools just once, and you will carry that knowledge everywhere within the composable Opaleye query language. Present in most of these tools is <code>C</code> which we saw before; we will use <code>C</code> every time we want to refer to a column in a query. For example, consider this query selecting all the users whose age equals their favorite number:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">q1 ::</span> <span class="dt">Query</span> (<span class="dt">PgR</span> <span class="dt">User</span>)
q1 <span class="fu">=</span> proc () <span class="ot">-&gt;</span> <span class="kw">do</span>
   u <span class="ot">&lt;-</span> queryTisch&#39; <span class="fu">-&lt;</span> ()
   restrict <span class="fu">&lt;&lt;&lt;</span> nullFalse <span class="fu">-&lt;</span> eq
      (u<span class="fu">^.</span>col (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;age&quot;</span>))
      (u<span class="fu">^.</span>col (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;favoriteNumber&quot;</span>))
   returnA <span class="fu">-&lt;</span> u</code></pre></div>
<p>So much happened there. Let’s walk step by step. First, by giving a type to this query we allowed <code>queryTisch'</code> to infer its return type. That is, the type-inferer knows that within this query <code>u</code> must be of type <code>PgR User</code>. Second, we see this strange <code>restrict &lt;&lt;&lt; nullFalse</code> thing: the <code>restrict</code> here is the one exported from <code>opaleye-sot</code>, which is just like the <code>restrict</code> from <code>opaleye</code> except it works on <code>Kol PGBool</code> instead of <code>Column PGBool</code> for the reasons we explained before when we talked about <code>Kol</code> and <code>Koln</code>. Now, even if we don’t yet understand how the input <code>eq</code> expression works, we must acknowledge one thing: Comparing two <code>NULL</code>able columns like <code>&quot;age&quot;</code> and <code>&quot;favoriteNumber&quot;</code> for equality might result in a <code>NULL</code> value in SQL, so <code>opaleye-sot</code> forces us to deal with that fact. <code>eq</code> is a very polymorphic function that works for any combination of <code>Kol</code> or <code>Koln</code> arguments you may apply it to. Its return type, on the other hand, is always fully determined by the input arguments, and it will always be <code>Koln</code> if there was one among the passed in arguments like in our case. So we have <code>restrict</code> expecting a <code>Kol PGBool</code> and <code>eq</code> returning a <code>Koln PGBool</code>. <code>nullFalse</code> is simply an arrow function that converts the latter to the former, transforming a possible <code>NULL</code> value to <code>FALSE</code>. After combining all of this, we simply return <code>u</code>. That is, this query will accomplish the same as the following SQL:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">SELECT</span> <span class="ot">&quot;id&quot;</span>, <span class="ot">&quot;name&quot;</span>, <span class="ot">&quot;favoriteNumber&quot;</span>, <span class="ot">&quot;age&quot;</span>
  <span class="kw">FROM</span> <span class="ot">&quot;public&quot;</span>.<span class="ot">&quot;user&quot;</span>
 <span class="kw">WHERE</span> <span class="ot">&quot;age&quot;</span> <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>
   <span class="kw">AND</span> <span class="ot">&quot;favoriteNumber&quot;</span> <span class="kw">IS</span> <span class="kw">NOT</span> <span class="kw">NULL</span>
   <span class="kw">AND</span> <span class="ot">&quot;age&quot;</span> = <span class="ot">&quot;favoriteNumber&quot;</span></code></pre></div>
<p>Of course the SQL generated by Opaleye will be uglier, but we are not here for the looks. If we try to compile this query, however, we will fail; we will get a type-checker error saying that the following instance is missing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Comparable</span> <span class="dt">User</span> <span class="st">&quot;age&quot;</span> <span class="dt">User</span> <span class="st">&quot;favoriteNumber&quot;</span></code></pre></div>
<p>In <code>opaleye-sot</code> every binary operation between two columns will require that a <code>Comparable</code> instance exists between them. This is designed so as to prevent accidentally comparing columns whose types are the same but whose meanings are completely different and not intended to be compared. By forcing us to explicitly ask the compiler for permission to compare across columns we can prevent more of <em>the wrong SQL</em>. Defining <code>Comparable</code> instances is very cheap as we only have to specify, in the instance head, the names of the columns we want to compare as well as the tables where each of them belongs. No instance methods need to be defined. Of course, the type-checker will reject instances for tables or columns that do not exist, or for columns whose types are different. For example, both <code>Comparable User &quot;age&quot; User &quot;falseColumn&quot;</code> and <code>Comparable User &quot;age&quot; User &quot;name&quot;</code> will fail to compile. I won’t explain here how this is achieved, but you are invited to learn more it about in <code>opaleye-sot</code>’s source code.</p>
<p>Next we need to pay attention to the expressions <code>u^.col (C::C &quot;age&quot;)</code> and <code>u^.col (C::C &quot;favoriteNumber&quot;)</code>. We already know that <code>u</code> is a <code>PgR User</code>, and that <code>C::C &quot;age&quot;</code> and <code>C::C &quot;favoriteNumber&quot;</code> is what we use to reference two columns uniquely identified by those names. There are only two new pieces here: <code>^.</code> and <code>col</code>. The first one, <code>^.</code>, comes from Edward Kmett’s <a href="https://hackage.haskell.org/package/lens"><code>lens</code></a> library and there’s not much to say about it that hasn’t been said before: Given a term <code>s :: s</code> and a term <code>l :: Lens' s a</code>, then <code>s ^. l :: a</code>. In our case, <code>u</code> is that <code>s</code>, and <code>col (C::C &quot;age&quot;)</code> and <code>col (C::C &quot;favoriteNumber&quot;)</code> are our <code>l</code>s.</p>
<p>What is <code>col</code> then? It is just a <code>Lens</code> to the value of a column, and its type is something like the following—here simplified and restricted to <code>HsR t</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">col ::</span> <span class="dt">C</span> c <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> (<span class="dt">HsR</span> t) (<span class="dt">Tagged</span> (<span class="dt">TC</span> t c) a)</code></pre></div>
<p>It doesn’t show up in this simplified type signature, but <code>a</code> is fully determined by <code>t</code> and <code>c</code>: It is the very same <code>a</code> that we expect <code>PgR t</code> to have at the column named <code>c</code>. If we recall the type <code>PgR User</code> reduces to, then we can see what <code>col</code> does in practice. Here is <code>PgR User</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Tagged</span>
  (<span class="dt">T</span> <span class="dt">User</span>)
  (<span class="dt">Record</span>
    <span class="ch">&#39;[ Tagged (TC User &quot;id&quot;)             (Kol PGInt4)</span>
     , <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;name&quot;</span>)           (<span class="dt">Kol</span> <span class="dt">PGText</span>)
     , <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;favoriteNumber&quot;</span>) (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
     , <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;age&quot;</span>)            (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
     ])</code></pre></div>
<p>And here are the types that <code>col</code> can take, simplified:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">col (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;id&quot;</span>)
<span class="ot">  ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">PgR</span> <span class="dt">User</span>) (<span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;id&quot;</span>) (<span class="dt">Kol</span> <span class="dt">PGInt4</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">col (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;name&quot;</span>)
<span class="ot">  ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">PgR</span> <span class="dt">User</span>) (<span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;name&quot;</span>) (<span class="dt">Kol</span> <span class="dt">PGText</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">col (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;favoriteNumber&quot;</span>)
<span class="ot">  ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">PgR</span> <span class="dt">User</span>) (<span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;favoriteNumber&quot;</span>) (<span class="dt">Koln</span> <span class="dt">PGInt4</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">col (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;age&quot;</span>)
<span class="ot">  ::</span> <span class="dt">Lens&#39;</span> (<span class="dt">PgR</span> <span class="dt">User</span>) (<span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;age&quot;</span>) (<span class="dt">Koln</span> <span class="dt">PGInt4</span>))</code></pre></div>
<p>In reality <code>col</code> is not just a <code>Lens' s a</code> like we see here, but a full blown <code>Lens s s' a a'</code> where <code>s</code> and <code>s'</code> can be any of <code>HsR t</code>, <code>HsI t</code>, <code>PgR t</code>, <code>PgRN t</code> or <code>PgW t</code>, and <code>a</code> and <code>a'</code> are fully determined by <code>c</code> and <code>s</code> or <code>s'</code> respectively. Which means that <code>col</code> will be useful in many other scenarios such as extracting data from an <code>HsR t</code> result or updating the value in a column as well.</p>
<p>Now that we know what <code>nullFalse</code> does, and that <code>u^.col (C::C &quot;age&quot;)</code> is of type <code>Tagged (TC User &quot;age&quot;) (Koln PGInt4)</code> and that <code>u^.col (C::C &quot;favoriteNumber&quot;)</code> is of type <code>Tagged (TC User &quot;favoriteNumber&quot;) (Koln PGInt4)</code>, we can conclude that <code>eq</code> must satisfy this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eq ::</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;age&quot;</span>) (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> <span class="dt">User</span> <span class="st">&quot;favoriteNumber&quot;</span>) (<span class="dt">Koln</span> <span class="dt">PGInt4</span>)
   <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span></code></pre></div>
<p>And indeed it does, but there’s much more to it than this monomorphic type. If we look at the type of <code>eq</code> in <code>opaleye-sot</code> we find this appalling type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eq ::</span> <span class="dt">Op_eq</span> x a b c <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</code></pre></div>
<p><code>Op_eq</code> is a constraint synonym, and if we were to expand it and follow it we would find that, like clockwork, it has many little pieces yet it is very precise, leading to good type inference even in light of such seemingly abstract nonsense. We will not do that exercise today though, instead we will just read the documentation for <code>eq</code> to understand how it is supposed to be used:</p>
<div style="font-style:italic">
<blockquote>
<p>Documentation for <code>eq :: Op_eq x a b c =&gt; a -&gt; b -&gt; c</code></p>
<p><code>opaleye-sot</code>’s polymorphic counterpart to <code>opaleye</code>’s <code>.==</code>.</p>
<p>Mnemonic reminder: EQual.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eq ::</span> <span class="dt">Kol</span>  x <span class="ot">-&gt;</span>                  <span class="dt">Kol</span>  x  <span class="ot">-&gt;</span> <span class="dt">Kol</span>  <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Kol</span>  x <span class="ot">-&gt;</span>                  <span class="dt">Koln</span> x  <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Kol</span>  x <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t c) (<span class="dt">Kol</span>  x) <span class="ot">-&gt;</span> <span class="dt">Kol</span>  <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Kol</span>  x <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t c) (<span class="dt">Koln</span> x) <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Koln</span> x <span class="ot">-&gt;</span>                  <span class="dt">Kol</span>  x  <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Koln</span> x <span class="ot">-&gt;</span>                  <span class="dt">Koln</span> x  <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Koln</span> x <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t c) (<span class="dt">Kol</span>  x) <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Koln</span> x <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t c) (<span class="dt">Koln</span> x) <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span></code></pre></div>
<p>Any of the above combinations with the arguments fliped is accepted too. Additionally, a <code>Comparable</code> constraint will be required if you try to compare two <code>Tisch</code>-aware columns directly; that is, a <code>Kol</code> or a <code>Koln</code> tagged with <code>TC t c</code>, such as those obtained with <code>col</code>. Here are some simplified example type signatures of this scenario just so that you get an idea:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eq ::</span> <span class="dt">Comparable</span> t1 c1 t2 c2
   <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t1 c1) a
   <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t2 c2) b
   <span class="ot">-&gt;</span> <span class="dt">Kol</span>  <span class="dt">PGBool</span>
<span class="ot">eq ::</span> <span class="dt">Comparable</span> t1 c1 t2 c2
   <span class="ot">=&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t1 c1) a
   <span class="ot">-&gt;</span> <span class="dt">Tagged</span> (<span class="dt">TC</span> t2 c2) b
   <span class="ot">-&gt;</span> <span class="dt">Koln</span> <span class="dt">PGBool</span></code></pre></div>
<p><em>Important</em>: <code>opaleye</code>’s <code>Column</code> is deliberately not supported. Use <code>kol</code> or <code>koln</code> to convert a <code>Column</code> to a <code>Kol</code> or <code>Koln</code> respectively.</p>
<p><em>Debugging hint</em>: If the combination of <code>a</code> and <code>b</code> that you give to <code>eq</code> is unacceptable, you will get an error from the type-checker saying that an <code>Op2</code> instance is missing. Do not try to add a new instance for <code>Op2</code>, it is an internal class that already supports all the possible combinations of <code>x</code>, <code>a</code>, <code>b</code>, and <code>c</code>. Instead, make sure your are not trying to do something funny such as comparing two <code>Koln</code>s for equality and expecting a <code>Kol</code> as a result. That is, you would be trying to compare two nullable columns and ignoring the possibilty that one of the arguments might be <code>NULL</code>, leading to a <code>NULL</code> result.</p>
</blockquote>
</div>
<p>And then, without going into the details of <code>Op_eq</code>, its documentation sheds some light about its purpose:</p>
<div style="font-style:italic">
<blockquote>
<p>Documentation <code>Op_eq x a b c</code></p>
<p>Constraints on arguments to <code>eq</code>.</p>
<p>Given as <code>a</code> and <code>b</code> any combination of <code>Kol x</code>, <code>Koln x</code> or their respective wrappings in <code>Tagged (TC t c)</code>, get <code>c</code> as result, which will be <code>Koln PGBool</code> if there was a <code>Koln x</code> among the given arguments, otherwise it will be <code>Kol PGBool</code>.</p>
<p>This type synonym is exported for two reasons: First, it increases the readability of the type of <code>eq</code> and any type errors resulting from its misuse. Second, if you are taking any of <code>a</code> or <code>b</code> as arguments to a function where <code>eq</code> is used, then you will need to ensure that some constraints are satisfied by those arguments. Adding <code>Op_eq</code> as a constraint to that function will solve the problem.</p>
<p><em>To keep in mind</em>: The type <code>c</code> is fully determined by <code>x</code>, <code>a</code>, and <code>b</code>. This has the practical implication that when both <code>Kol z</code> and <code>Koln z</code> would be suitable types for <code>c</code>, we make a choice and prefer to only support <code>Kol z</code>, leaving you to use <code>koln</code> on the return type if you want to convert it to <code>Koln z</code>. This little inconvenience, however, significantly improves type inference when using <code>eq</code>.</p>
</blockquote>
</div>
<p>Functions like <code>eq</code> are the other big thing that <code>opaleye-sot</code> brings to the <code>opaleye</code> query language. And, as complicated as their implementations might be, the net benefit of <code>eq</code> for the end-user writing a query in the Opaleye query language is huge: It is <em>the single entry point</em> to comparing for equality any any two comparable things, no matter where there are contained; and as many constraints will be required on those comparable things in order to ensure that we don’t accidentally fall into <em>the wrong SQL</em> trap. Of course, highly polymorphic functions like <code>eq</code> wouldn’t be desirable if they were to completely abandon type inference and result in incomprehensible error messages when used wrong, but with some careful design and experimentation, the implementor of functions like <code>eq</code> can make the proper trade-offs and come up with something that works well in most scenarios while leaving room for some manual calibration of the types in the rare cases when it is needed. In our case, the implementation of <code>eq</code> and similar functions relies on the <code>FunctionalDependencies</code> language extension to achieve this.</p>
<p>Just like <code>eq</code> is used for comparing for equality, there are similarly typed functions for comparing for order, logical conjunction and disjunction, etc. Additionally, unary operators like SQL’s <code>NOT</code> are upgraded to work over a similar range of argument types in <code>opaleye-sot</code>. In general, any unary or binary function operating on <code>Column</code> can be upgraded to be as polymorphic as <code>eq</code> using some combination of <code>op1</code>, <code>op2</code>, <code>liftKol1</code>, <code>liftKol2</code>, and other similar functions exported by <code>opaleye-sot</code>.</p>
<h2 id="updating-rows">Updating rows</h2>
<p>The last topic we will cover today is updating rows. <code>opaleye-sot</code> exports a function named <code>runUpdate</code> which behaves just like <code>opaleye</code>’s own <code>runUpdate</code>, except it is a bit more polymorphic and it is intended to work with <code>Kol</code>s and <code>Koln</code>s instead of <code>Column</code>s. Its type, simplified for our example, looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runUpdate
<span class="ot">  ::</span> <span class="dt">Connection</span>
  <span class="ot">-&gt;</span> <span class="dt">Table</span> w r
  <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> w)
  <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> <span class="dt">Kol</span> <span class="dt">PGBool</span>)
  <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></code></pre></div>
<p>Skipping the obvious <code>Connection</code>, let’s try to fill one by one the arguments. We will be inserting a row to our <code>User</code> table, which we know we can obtain from <code>table (T::T User)</code>. Now, with <code>w</code> fixed to <code>PgW User</code> and <code>r</code> fixed to <code>PgR User</code>, we could proceed to fill the missing functions. However, let’s pay attention to the <code>r -&gt; w</code> function that we will need to provide first, which will be of type <code>PgR User -&gt; PgW User</code> when specialized to our particular use case: What is the difference between <code>PgR User</code> and <code>PgW User</code>? As we saw before, the only difference is that the columns that can take a <code>DEFAULT</code> value when being written need to be wrapped in <code>WDef</code>. The practical implication of such difference in the types is that even if we just wanted update single value in a single column in the <code>User</code> table, we would still need to manually wrap all the columns that can take a <code>DEFAULT</code> value in <code>WDef</code>. <em>Manually</em>, a word by now we abhor, even more so when we know that this process is entirely mechanical. But similarly to how we demonstrated that it was possible to go from <code>HsI t</code> to <code>PgW t</code> by means of <code>toPgW'</code>, it is also possible to go from <code>PgR t</code> to <code>PgW t</code> by means of <code>update'</code>, so we could just precompose <code>update'</code> with a function of type <code>PgW t -&gt; PgW t</code> that only worries about updating the columns that will change. Knowing that this is such a common scenario, <code>opaleye-sot</code> exports a function <code>runUpdateTisch</code> specially designed to work with <code>Tisch</code> instances, which we will use instead of <code>runUpdate</code>—its type here simplified for our explanatory purposes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runUpdateTisch
<span class="ot">  ::</span> <span class="dt">Connection</span>
  <span class="ot">-&gt;</span> <span class="dt">T</span> t
  <span class="ot">-&gt;</span> (<span class="dt">PgW</span> t <span class="ot">-&gt;</span> <span class="dt">PgW</span> t)
  <span class="ot">-&gt;</span> (<span class="dt">PgR</span> t <span class="ot">-&gt;</span> <span class="dt">Kol</span> <span class="dt">PGBool</span>)
  <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></code></pre></div>
<p>For example, let’s say last week it was my birthday and I just realized my new age is also my new favorite number, and I want to reflect that in the <code>User</code> table:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">runUpdateTisch conn (<span class="dt">T</span><span class="ot">::</span><span class="dt">T</span> <span class="dt">User</span>)
  (\u <span class="ot">-&gt;</span> set (cola (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;favoriteNumber&quot;</span>))
             (<span class="dt">WVal</span> (u<span class="fu">^.</span>cola (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;age&quot;</span>))) u)
  (\u <span class="ot">-&gt;</span> eq (kol (<span class="st">&quot;Renzo&quot;</span><span class="ot"> ::</span> <span class="dt">Text</span>))
            (u<span class="fu">^.</span>cola (<span class="dt">C</span><span class="ot">::</span><span class="dt">C</span> <span class="st">&quot;name&quot;</span>)))</code></pre></div>
<p>This code will generate an SQL comparable to this</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">UPDATE</span> <span class="ot">&quot;public&quot;</span>.<span class="ot">&quot;user&quot;</span>
   <span class="kw">SET</span> <span class="ot">&quot;favoriteNumber&quot;</span> = <span class="ot">&quot;age&quot;</span>
 <span class="kw">WHERE</span> <span class="ot">&quot;name&quot;</span> = <span class="st">&#39;Renzo&#39;</span></code></pre></div>
<p>Of course, I’m being optimistic and assuming I am the only Renzo in the database, but hopefully you get the idea. The first function that we passed to <code>runUpdate</code> changes the values in the columns of the row as needed, in our case updating the <code>&quot;favoriteNumber&quot;</code> column as planed using the <a href="https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Setter.html#v:set"><code>set</code></a> function from the <code>lens</code> library. The other function we passed is the boolean predicate where we select which columns we want to update—notice how we used <code>eq</code> again here. The only new thing here is <code>cola</code>, which behaves just like the <code>col</code> lens we saw before, except it removes the <code>Tagged (TC t c)</code> wrapper around the value in the representation for the column that <code>col</code> would otherwise keep.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This is our stop. We have learned how <code>opaleye-sot</code> befriends the Haskell type system to keep us safe and free from boilerplate, we learned how to reduce a problem to its essentials, we have seen how it is possible to clean up a public API so that it covers as many scenarios as possible while staying correct and predictable, we learned how to help users accomplish their goals with as little friction and as much safety as possible, we have given a practical perspective to advanced type feature systems, and maybe we have saved the next billion dollars as well.</p>
<p>We did embrace Opaleye and the generation of well-formed and <em>not wrong</em> SQL as our scenario, but it is important to realize that these techniques and approaches are still applicable in other scenarios. It is up to us, as people who understand a problem at hand, to try and teach the type system as much as we can about that problem. And even if we don’t yet understand the problem: Let’s talk to the type system about it; it will help us understand. Remember, the type system is not magic, it is a logical reasoning tool.</p>
<h2 id="is-it-on-hackage-yet">Is it on Hackage yet?</h2>
<p>Not yet. Up until now I have been building <code>opaleye-sot</code> as a side-effect of a another project I have been trying to bootstrap, which means that the features currently present in <code>opaleye-sot</code> are the ones I have happened to need and have had time to complete. But of course, there are a lot of things missing such as more binary operators, support for composite columns, a story for aggregation and perhaps a way of checking at runtime that the <code>Tisch</code> you compiled has the expected shape in the database. So in a sense, this article is also an invitation for you to contribute to <code>opaleye-sot</code>, even if just by asking for some feature to exist or some documentation to improve. <code>opaleye-sot</code> will be on Hackage once it can be considered <em>production ready</em>. Meanwhile, I invite you to go and explore its <a href="https://github.com/k0001/opaleye-sot">source code</a>, as well its <a href="">documentation</a>. In the source code you will find a tutorial in the works too, with some additional examples. All of it free and open source as you would justifiably expect.</p>
<h2 id="discussion">Discussion</h2>
<p>You can discuss this comment at <a href="">reddit</a>.</p>
<div style="margin-left:1em; padding-left:1em; border-left: solid #111 1px;">
<p><em>By <a href="../">Renzo Carbonara</a>. First published in October 2015.<br/> This work is licensed under a <a rel="license"
href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</em></p>
</div>
</body>
</html>
